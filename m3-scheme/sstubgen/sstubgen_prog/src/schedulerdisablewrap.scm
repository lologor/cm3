;;
;; $Id$
;;
;;
;; Process Modula-3 interfaces in Scheme
;;
;; 
;; Copyright (c) 2009-2011, Generation Capital Ltd.  All rights reserved.
;;
;; Author : Mika Nystrom <mika@alum.mit.edu>
;;

(require-modules "basic-defs" "display" "hashtable" "struct" "set" 
                 "pregexp/pregexp")

;;
;; Modula-3 wrapper
;;
;; phase 1.  make-standard-stuff
;;
;;

;;
;; Dependencies.  The code in this file depends on (at least) the
;;                following Modula-3 interfaces.
;;
;;   TypeTranslator
;;   ValueTranslator
;;      [which depend on]
;;        Type   (generated by AstToType)
;;        Value  (generated by AstToValue)
;;          [which depend on]
;;             AST interfaces in m3tk
;;
;; The following lists are assumed to exist on startup:
;;
;; the-types
;; the-exceptions
;; the-vars
;; the-procs
;; the-consts
;; the-protos
;; the-basetypes
;; the-sourcefiles
;;
;;  ;;;   explanation of individual variables   ;;;
;;
;; the-types
;;     s-expressions for each of the types mentioned in the interface
;;
;; the-exceptions
;;     s-expressions for each of the exceptions mentioned in the interface
;;
;; the-vars
;;     s-expressions for each of the variables declared in the interface
;;
;; the-procs
;;     s-expressions for each of the procedures declared in the interface
;;
;; the-consts
;;     s-expressions for each of the constants declared in the interface
;;
;; the-protos
;;     s-expressions for empty type expressions as declared in Type 
;;     interface
;;
;; the-basetypes
;;     s-expressions for the Modula-3 base types
;;
;; the-sourcefiles
;;     list of filenames for interfaces processed.  Normally just one
;;     filename, if the Quake template has been used.
;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;       ENTRY POINTS         ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;      FOR CM3/M3BUILD       ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define (make-standard-stuff intf-name)
  ;;
  ;; phase 1 of stub generation.  
  ;; build all the Scheme stubs for a given M3 interface
  ;;
  (if (stale-output? intf-name) 
      (begin
        (set! global-env (env-type 'new))
        (write-files intf-name the-procs the-types global-env)
        )
      (dis "Scheme stubs up to date: " intf-name dnl))
  )

(define (force-string s)
  (if (symbol? s) (symbol->string s) s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;      CONFIGURATIONS        ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define config-check-staleness #t)
;; set this to #t to check file staleness before rebuilding,
;; otherwise rebuilding "always" happens

(define (reload) (load "/home/mika/t/mscheme/sstubgen/program/src/schedulerdisablewrap.scm"))
;; utility function for interactive testing

(set-warnings-are-errors! #t)
;; for debugging


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;      INTERNAL REPS         ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-type-name interface name) (cons interface name))

(define (extract-field  field-name type)
  (let ((ass (assoc field-name type)))
    (if (not (pair? ass))
        (error "No assoc for " field-name " in " type)
        (cdr ass))))

(define (have-field? field-name type)
  (assoc field-name type))

(define (type-type type) (car type))

(define (get-alias type) 
  (if (not (have-field? 'alias type)) '()
      (let ((qid (extract-field 'alias type)))
        (if (null? qid) 
            '()
            (cleanup-qid qid)))))

(define (get-name type) 
  (if (not (have-field? 'name type)) '()
      (let ((qid (extract-field 'name type)))
        (if (null? qid) 
            '()
            (cleanup-qid qid)))))

(define (cleanup-qid qid)
  (if (= 0 (string-length (symbol->string (extract-field 'intf qid))))
      (cons '() (extract-field 'item qid))
      (cons (extract-field 'intf qid)
            (extract-field 'item qid))))

(define (string-type-alias type sep env)
  (let ((tn (get-alias type)))
    (stringify-qid tn sep env)))

(define (string-type-name type sep env)
  (let ((tn (get-name type)))
    (stringify-qid tn sep env)))

(define (stringify-qid tn sep env)
  (if (not (pair? tn))
      (error "stringify-qid : not a pair : " tn))

  (if (not (or (null? (car tn)) (symbol? (car tn))))
      (error "stringify-qid : car is not a symbol or null : " tn))

  (if (not (symbol? (cdr tn)))
      (error "stringify-qid : cdr is not a symbol : " tn))

  (if (or (null? (car tn))
          ((env 'get 'exports) 'member? (car tn)))
      (symbol->string (cdr tn))
      (begin
        ((env 'get 'imports) 'insert! (car tn))
        (string-append (symbol->string (car tn))
                       sep
                       (symbol->string (cdr tn))))))

(define (find-type-alias named types)
  (car 
   (filter (lambda (t) (equal? (get-alias t) named))
           types)))

(define (find-named-element named lst)
  (let ((matches (filter 
                  (lambda (t) (equal? (extract-field 'name t) named))
                  lst)))
    (if (null? matches) 
        (error "find-named-element: no matches : " named " " lst))
    (if (not (null? (cdr matches)))
        (error "find-named-element: multiple matches : " named " " lst))
    (car matches)))

;; subranges
(define (base-type-type type) (type-type (base-type type)))

(define (base-type type)
  (if (not (eq? (car type) 'Subrange))
      (error "cant get base type of " (car type))
      (let ((base (extract-field 'base type)))
        (cond ((eq? (type-type base) 'UserDefined) base)
              ((eq? type base)       base) ;; integer
              (else (base-type base))))))

(define (intersperse lst sep)
  ;; this routine MUST BE tail-recursive, or we will definitely
  ;; run out of stack space!
  (define (helper lst so-far)
    (cond ((null? lst) so-far)
          ((null? (cdr lst)) (cons (car lst) so-far))

          (else 
           (helper (cdr lst) 
                   (cons sep  (cons (car lst) so-far))))))
  (reverse (helper lst '()))
  )

(define (infixize string-list sep)
  (if (null? string-list) ""
      (apply string-append 
             (intersperse string-list sep))))

(define (formals-from-sig sig)
  (filter (lambda(f) (and (pair? f) (eq? (car f) 'Formal)))
          (assoc 'formals sig)
          ))

(define (format-formal-param f)
  (symbol->string (extract-field 'name f)))

(define (format-formal-decl f env)
  (let ((name (extract-field 'name f))
        (mode (extract-field 'mode f))
        (type (extract-field 'type f)))
    (string-append
     (case mode
       ((Mode.Var) "VAR ")
       ((Mode.Value) "VALUE ")
       ((Mode.Readonly) "READONLY ")
       (else (error "unknown mode " mode)))
     (symbol->string name)
     " : "
     (format-type type env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;       FORMAT TYPES         ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define bad-type '())

(define (format-object-super t env)
  (let ((super (extract-field 'super t)))
    (if (null? super) "" (format-type super env))))

(define (format-branding t)
  (if (extract-field 'branded t)
      (string-append " BRANDED " 
                     (let ((brand (extract-field 'brand t)))
                       (if (null? brand) "" (string-append "\"" brand "\""))))
      ""))

(define (format-field f env)
  (let ((type (extract-field 'type f)))
    (string-append
     (extract-field 'name f)
     " : "
     (format-type type env)
     (let ((default (extract-field 'default f)))
       (if (not (null? default))
           (string-append " := " (format-type-value type default env))
           "")))))

(define (format-fields t env)
  (apply string-append 
         (map 
          (lambda(fld) (string-append "    " (format-field fld env) ";" dnl))
          (extract-field 'fields t))))

(define (extract-and-format-qid d env)
  (let* ((qid (extract-field 'qid d))
         (intf (extract-field 'intf qid))
         (item (extract-field 'item qid)))
    (stringify-qid (cons intf item) "." env)))

(define (format-formal f env) 
  (let ( (mode (extract-field 'mode f)) )
    (string-append
     (case mode
       ((Mode.Var) "VAR ")
       ((Mode.Value) "VALUE ")
       ((Mode.Readonly) "READONLY ")
       (else (error "unknown mode " mode)))
     (format-field f env))))

(define (format-exceptions x env)
  (infixize (map (lambda(xx)(extract-and-format-qid xx env)) x) ", "))

(define (format-parenthesized-signature sig env . optional-me)

  ;; format a procedure (or method) signature
  (string-append 
   "("
   (infixize  (append optional-me 
                      (map (lambda(x)(format-formal x env)) 
                           (extract-field 'formals sig))) "; ")
   ")"

   (let ((result (extract-field 'result sig)))
     (if (null? result) ""
         (string-append " : " (format-type result env))))

   (let ((raises (extract-field 'raises sig)))
     ;; note the distinction here.
     ;; raises null : raises ANY
     ;; a null list : raises {}
     ;; else.. the exceptions listed
     (cond ((null? raises) " RAISES ANY")
           ((and (pair? raises) (null? (car raises))) "")
           (else (string-append " RAISES { "
                                (format-exceptions (car raises) env)
                                " }"))))))

(define (format-method m env)
  (let ((name (extract-field 'name m))
        (sig (extract-field 'sig m))
        (default (extract-field 'default m)))
    (string-append "    " name (format-parenthesized-signature sig env)
                   (if (not (null? default)) 
                       (string-append " := " (extract-and-format-qid default env) )
                       ""))
    ))

(define (format-object-methods t env)
  (apply string-append 
         (map 
          (lambda(f) (string-append (format-method f env) ";" dnl))
          (extract-field 'methods t))))

(define (format-override m env)
  (let ((name (extract-field 'name m))
        (default (extract-field 'default m)))
    (string-append "    " name " := " (extract-and-format-qid default env) )

    ))

(define (format-object-overrides t env)
  (apply string-append 
         (map 
          (lambda(f) (string-append (format-override f env) ";" dnl))
          (extract-field 'overrides t))))

(define (unprotected-format-type t env)
  (cond ((is-basetype t) => 
                         (lambda(x)(string-append " " (symbol->string x) " ")))
        ((have-field? 'alias t) (string-type-alias t "." env))
        ((and (have-field? 'name t)(not (null? (extract-field 'name t)))) 
         (string-type-name t "." env))
        (else 
         (case (car t)
           ((Ref)
            (string-append " REF " (type-formatter 
                                    (extract-field 'target t)
                                    env
                                    )))

           ((Subrange)
            (let ((base (type-formatter (extract-field 'base t) env)))
              (string-append "[ VAL("(cdr (extract-field 'min t))  "," base ")"
                             ".."
                             "VAL("(cdr (extract-field 'max t))  "," base ") ]")
              ))

           ((OpenArray)
            (string-append 
             " ARRAY OF " 
             (type-formatter (extract-field 'element t) env)
             ))
           
           
           ((Array)
            (string-append
             " ARRAY " 
             (type-formatter (extract-field 'index t) env)
             " OF "
             (type-formatter (extract-field 'element t) env)
             )
            )

           ((Set)
            (string-append
             " SET OF " (type-formatter (extract-field 'range t) env)))

           ;; do we really want CHAR and WIDECHAR here?
           ((Char) " CHAR")
           
           ((WideChar) " WIDECHAR")

           ((Object)
            (string-append 
             (format-object-super t env)
             (format-branding t)
             " OBJECT" dnl
             (format-fields t env)
             " METHODS" dnl
             (format-object-methods t env)
             " OVERRIDES" dnl
             (format-object-overrides t env)
             " END" dnl))

           ((UserDefined) 
            (string-append " { " 
                           (infixize (extract-field 'elts t) ", ")
                           " } " dnl))

           ((Record)
            (string-append
             " RECORD " dnl
             (format-fields t env)
             " END" dnl))

           ((Procedure)
            (string-append
             " PROCEDURE"
             (format-parenthesized-signature (extract-field 'sig t) env)))

           ((Packed)
            (string-append " BITS " (extract-field 'size t) " FOR " (format-type (extract-field 'base t) env)))

           ((Opaque)
            (string-append
             " (* <: *) " (format-branding t) dnl
             (type-formatter (extract-field 'revealedSuperType t) env) dnl))

           (else (error "format-type: dont know how to format " t)))))
  )

(define (strip-names type)
  (filter-out '(alias name) type))

(define (format-type t env)
  (unwind-protect
   (unprotected-format-type t env)
   () ;; finally-clause
   (begin
     (set! bad-type t) ;; remember for debugging
     (error "format-type caught error formatting " t dnl dnl))))

(define type-formatter format-type)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;       FORMAT VALUES        ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define bad-values '())

(define (is-reference-type? type)
  (member? (car type) '(Opaque Ref Procedure Object)))

(define (format-type-value type value env)
  (case (car value)

    ((Ordinal) 
     ;; special case for NIL: (Ordinal . 0)
     
     (if (is-reference-type? type)
         (if (not (= (cdr value) 0))
             (error "Ordinal initializer for Ref, non-zero value : " type 
                    ", " value)
             " NIL")
         (string-append 
          " VAL(" 
          (number->string (cdr value))", "  (type-formatter type env)
          ")")))
    
    ((LongFloat)
     (string-append
      " FLOAT("
      (number->LONGREAL (cdr value))
      ", "
      (type-formatter type env)
      ")"
      ))

    ((Proc) (stringify-qid (cleanup-qid (cdr value))
                           "."
                           env))

    ((Set)
     (string-append
      " " (type-formatter type env)
      " { "

      (infixize 
       (map (lambda(m)(format-set-member m type env)) (cdr value))
       ", ")

      " } "))
    
    ((Txt)
     (string-append "\"" (cdr value) "\""))

    ((ArrayOrRecord)

     (string-append
      " " (type-formatter type env)
      " { "
      (infixize
       (let loop ((i 0)
                  (elements (cdr value)))
         (if (null? elements) 
             '()
             (cons (format-element (car elements) type i env)
                   (loop (+ i 1) (cdr elements) ))))
       ", ")
      " } " dnl))

    (else
     (set! bad-values (cons (cons type value) bad-values))
     "**NOTYET**")
    ))

(define (format-set-member m set-type env)
  ;; format the initializer for a set member
  (format-type-value (extract-field 'range set-type) m env))

(define (format-element e container-type index env)
  ;; format the initializer of a single item in an ARRAY or RECORD
  ;; dispatches on the container type
  (case (car container-type)

    ((Record) 
     (format-record-element e container-type index env))

    ((OpenArray Array) 
     (format-array-element e container-type index env))
    
    (else (error "cant format element of " (car container-type)))))

(define (format-array-element e container-type index env)
  ;; format the initializer for an array element
  (case (car e)
    ((Propagate) " .. ")
    
    ((Range) 
     (let* ((elem-valu (cdr e))
            (elem-type (extract-field 'element container-type)))
       (string-append 
        " "
        (format-type-value elem-type elem-valu env)
        )))
    
    (else (error "unknown element type " (car e)))
    ))


(define (format-record-element e container-type index env)
  ;; format the initializer for a record member
  (case (car e)
    ((Actual) 
     (let* ((field-name (cadr e))
            (field-valu (caddr e))
            (field-desc (find-named-element 
                         field-name (extract-field 'fields container-type)))
            (field-type (extract-field 'type field-desc)))
       (string-append
        " "
        field-name
        " := " 
        (format-type-value field-type field-valu env)
        
        )
       
       ))
    
    ((Range) 
     (let* ((field-valu (cdr e))
            (field-desc (nth (extract-field 'fields container-type) index))
            (field-type (extract-field 'type field-desc)))
       (string-append 
        " "
        (format-type-value field-type field-valu env)
        )))
    
    (else (error "unknown element type " (car e)))
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (filter-out keys struct)
  (filter
   (lambda (x) (or (not (pair? x))(not (memq (car x) keys))))
   struct))

(define (lp xx)
  ;; "line printing"

  (begin 
    (map (lambda(x) (dis x dnl)) xx) 
    #t))

(define (lp2 xx)
  (begin
    (map (lambda(x) (begin (lp x)(dis "----------------------" dnl)) #t) xx)
    #t
    ))

(define (make-pair-hash-table size) ;; silly
  (define (pair-hash p) 0)
  (make-hash-table size pair-hash))

(define env-type 
  (make-struct-type
   'env-type
   `((exports       ,(lambda()(make-symbol-set 100))) 
     ;; interfaces we export

     (imports       ,(lambda()(make-symbol-set 100))) 
     ;; interfaces we need to import

     (symbols       ,(lambda()(make-symbol-set 100)))
     ;; symbols we need to build at load time for runtime comparison,
     ;; against method names, exception names, etc.

     (convert->m3-req          ,(lambda()(make-symbol-hash-table 100))) 
     ;; converters->m3 requested

     (convert->scm-req          ,(lambda()(make-symbol-hash-table 100))) 
     ;; converters->scm requested

     (convert-blt          ,(lambda()(make-symbol-set 100))) 
     ;; converters built

     (procedure-call-stubs ,(lambda()(make-pair-hash-table 100))) 
     ;; procedure call stubs built

     )))

(define global-env (env-type 'new))

(define (global-format t)
  (begin
    (set! global-env (env-type 'new))
    (format-type t global-env)
    ))

(define (init-symbol-set . syms)
  (let ((res (make-symbol-set 100)))
    (map (lambda(x)(res 'insert! x)) syms)
    res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (format-arbitrary-identifier sym)
  ;; convert . to DOT
  (string-append
   "SYMBOL_"
   (list->string
    (apply append 
           (map (lambda(c)(if (eq? c #\.) (string->list "DOT") (list c)))  
                (string->list (force-string sym)))))))

(define (make-symbol from env) ;; equivalent to SchemeSymbol.FromText(sym)
  (let ((sym (cond ((string? from) (string->symbol from))
                   ((symbol? from)                 from )
                   (else ("error not string or symbol" from)))))
    ((env 'get 'symbols) 'insert! sym)
    ;;(string-append "SchemeSymbol.FromText(\"" sym "\")")
    ;; basic version

    (string->symbol (format-arbitrary-identifier from)) ;; optimized version
    
    )
)

(define (format-symbols symbol-list)
  (apply 
   string-append
   (map (lambda(ident)
          (string-append
           "VAR " (format-arbitrary-identifier ident)
           " := SchemeSymbol.FromText(\"" ident "\");" dnl))
        symbol-list)))

(define (format-load-time-symbols env)
  (format-symbols ((env 'get 'symbols) 'keys)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (format-const-value c env) ;; format constant from global env 
  (format-type-value
   (extract-field 'type c)
   (extract-field 'value c)
   env
   ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; test code
(set! type-formatter unprotected-format-type)
;;(map global-format (map strip-names the-types))

(define (m3type->m3identifier s)
  ;;
  ;; turn a legal Modula-3 type specifier into a legal Modula-3 identifier
  ;; (by hook or by crook)
  ;;
  (list->string
   (filter 
    (lambda (c) (or (char=? c #\_)
                    (char-alphabetic? c)
                    (char-numeric? c)))
    (map 
     (lambda (c) (cond ((char=? c #\.) #\_)
                       (else c)))
     (string->list s)))))

(define (is-basetype type)
  ;; returns string name of basetype or #f

  (define (is-opaque-basetype)
    ;; special handling for opaques, by name
    (let loop ((p the-basetypes))
      (cond ((null? p) #f)
            ((equal? (cdar p) type) (caar p))
            (else (loop (cdr p))))))

  

  (cond ((eq? 'Opaque (car type)) (is-opaque-basetype))
        ((equal? type (cdr (assoc 'ADDRESS the-basetypes))) 'ADDRESS)
        (else (let ((unnamed-type (strip-names type)))
                (let loop ((p the-basetypes))
                  (cond ((null? p) #f)
                        ((equal? (strip-names (cdar p)) unnamed-type) (caar p))
                        (else (loop (cdr p)))))))))

(define (string-quote s) (string-append "\"" s "\""))

(define (format-imports env)
  (let ((keys ((env 'get 'imports) 'keys)))
    (if (null? keys) 
        ""
        (apply string-append
               (map (lambda (i) 
                      (string-append 
                       "IMPORT " i ";" dnl)) 
                    keys)))))

(define (make-modules name              ;; name of interface
                      interface-decls   ;; stuff for .i3
                      module-decls      ;; stuff for .m3
                      module-code       ;; initialization block
                      env)
  (if (not (env 'get 'exports) 'member? name)
      (error "not member of exports : " name))
  (string-append
   "MODULE " name ";" dnl

   (format-imports env)

   dnl
   module-decls
   dnl
   "BEGIN" dnl
   module-code 
   "END " name "." dnl))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-conversion-routines type env)
  ;; make only the legal conversion routines
  ;; none for base types
  ;; to-scheme only for open arrays
  ;; to-scheme and to-modula for all others
  (if (is-basetype type) 
      #f
      (cons (make-to-scheme type env)
            (if (eq? (car type) 'OpenArray) 
                '()
                (list (make-to-modula type env))))))

(define (to-scheme-proc-name type env)
  ;;
  ;; if it's a base type, we call the base type conversion library
  ;; else we make the converter ourselves.
  ;;
  (if (and (is-basetype type) 
           (eq? (scheme-modula-conversion-mode (is-basetype type))
                'Concrete))
      (begin
        (stringify-qid
         (cons 'SchemeModula3Types
               (string->symbol (string-append "ToScheme_" (is-basetype type))))
         "."
         env))
      (let ((convert-req (env 'get 'convert->scm-req))
            (res 
             (string-append "ToScheme_" 
                            (m3type->m3identifier (type-formatter type env)))))
        (convert-req 'update-entry! (string->symbol res) type)
        res)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (filter-tree tree match-list converter)
  ;; very generic routine to search a tree for a "path" and
  ;; call converter on everything found down that path.
  ;; see prefix-formals for an example
  (map 
   (lambda (p) 
     (if (and (pair? p) 
              (eq? (car match-list) (car p)))  ;; any match?
         (if (null? (cdr match-list))          ;; final match?
             (cons (car p) (converter (cdr p)));; yes - convert 
             (cons (car p)                     ;; no - recurse
                   (filter-tree (cdr p) (cdr match-list) converter)))
         p ;; anything else
         ))
   tree))

(define (make-formal mode name type . default)
  `(Formal (mode . ,mode)(outOnly . #f)(name . ,name) (type . ,type) (default . , default)))

(define (prefix-formals prefix proc-type)
  ;; add a prefix to all the formals of a procedure (or method?) 
  ;; declaration
  (filter-tree proc-type 
               '(sig formals Formal name)
               (lambda(formal-name)
                 (string->symbol (string-append prefix formal-name)))))


(define (make-procedure-call-stub proc env)
  (let* ((qid (car proc))
         (m3pn (stringify-qid (cleanup-qid qid) "." env))
         (u3pn (stringify-qid (cleanup-qid qid) "_" env))
         (stub-name (string-append "CallStub_" u3pn))
         (proc-type (prefix-formals 'formal_ (cdr proc)))
         )

    (let ((stubs (env 'get 'procedure-call-stubs))
          (qualified-name (cleanup-qid qid)) 
          )
      (stubs 'delete-entry! qualified-name)
      (stubs 'add-entry! qualified-name stub-name))

    (make-named-procedure-call-stub proc-type m3pn u3pn stub-name "" env)))


(define dnldnl (string-append dnl dnl))

(define (spit-out intf-name proc-stubs proc-protos type-aliases types env)
  (cons
   (spit-out-intf intf-name proc-stubs proc-protos type-aliases env)
   (spit-out-impl intf-name proc-stubs '() types env)
   )
  )

(define (spit-out-intf intf-name proc-stubs proc-protos type-aliases env)
  (string-append
   (if is-unsafe "UNSAFE " "") "INTERFACE " intf-name ";" dnl
   "(* AUTOMATICALLY GENERATED DO NOT EDIT *)" dnl
   (format-imports env)
   dnl
   (infixize proc-protos dnldnl)
   dnl
   (infixize type-aliases dnldnl)
   dnl
   "CONST Brand = \"" intf-name "\";" dnl
   dnl
   "END " intf-name "." dnl
   )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (string-flatten-list lst)
  (define (helper x)
    (if (list? x) 
        (string-flatten-list x)
        x))
  (apply string-append (map helper lst)) )

;;(define (string-flatten . lst)
;;  (string-flatten-list lst))

(define (get-elements x)
  (cond ((null? x) '())
        ((pair? x) (append (get-elements (car x)) (get-elements (cdr x))))
        (else (list x))))

(define (string-flatten . lst)
  ;; this one is much faster because it uses array indexing in string-append
  ;; and then only a single Wx
  (apply string-append (get-elements lst)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (is-object-type? type)
  (and 
   (pair? type)
   (or 
    (eq? (car type) 'Object)
    (and (eq? (car type) 'Opaque)
         (is-object-type? (extract-field 'revealedSuperType type))))))

(define (is-ref-record-type? type)
  (and 
   (pair? type)
   (eq? (car type) 'Ref)
   (eq? (car (extract-field 'target type)) 'Record)))

(define (is-ref-array-type? type)
  (and 
   (pair? type)
   (eq? (car type) 'Ref)
   (or
    (eq? (car (extract-field 'target type)) 'Array)
    (eq? (car (extract-field 'target type)) 'OpenArray))))

(define (is-ref-type? type)
  (and 
   (pair? type)
   (eq? (car type) 'Ref)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (spit-out-impl intf-name proc-stubs converter-impls types env)
  (define (env-map func types)
    (map (lambda(t)(func t env)) types))

  ;; we have one little limitation so far...  we dont discover that
  ;; something is an array type or ref array type while processing the
  ;; current interface unless its already been given its own distinct
  ;; typename.  This mainly hits procedure return values---if we want
  ;; to unpack them, the user needs to specify the types separately
  ;; somehow.

  (let* (  (imports (env 'get 'imports))  )
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		(imports 'insert! 'SchedulerIndirection)
    
    (string-flatten
     (if is-unsafe "UNSAFE " "") "MODULE " intf-name ";" dnl
     "(* AUTOMATICALLY GENERATED DO NOT EDIT *)" dnl
     (format-imports env)
     dnl
     (infixize proc-stubs dnl) dnl
     
     dnl

     "BEGIN END " intf-name "." dnl
     )
    )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (check-non-nil-type varname typename env)
  ((env 'get 'imports) 'insert! 'Scheme)
  ((env 'get 'imports) 'insert! 'SchemeUtils)

  (string-append
   "    IF NOT ISTYPE("varname","typename") OR "varname"=NIL THEN" dnl
   "      RAISE Scheme.E(\"Not of type "typename" : \" & SchemeUtils.Stringify("varname"))" dnl
   "    END;" dnl
   )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-method-call-sig method type)
  (let* ((proc-type (prefix-formals 'formal_ method)))

    (filter-tree proc-type
                 '(sig formals)
                 (lambda(formals)
                   (cons (make-formal 'Mode.Implied 'this type) formals))

                 )
    ))

(define (make-an-op-registration type name proc-name env)
  ((env 'get 'imports) 'insert! 'SchemeProcedureStubs)
  (string-append
   "    SchemeProcedureStubs.RegisterOp(TYPECODE("
   (type-formatter type env)
   "),\"" name  "\"," proc-name");" dnl
   ))

(define (make-a-tc-registration type name env)
  ((env 'get 'imports) 'insert! 'SchemeProcedureStubs)
  (string-append
   "    SchemeProcedureStubs.RegisterTC(TYPECODE("(type-formatter type env)
   "),\"" name "\");" dnl
   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define (make-ref-type target)
  (list 'Ref 
        (cons 'traced #t)
        (cons 'target target)
        ))

(define (convert-value-to-modula type value env)
  (case (car type)
    ((OpenArray)
     (string-append
      (to-modula-proc-name (make-ref-type type)
                           env)
      "(" value ")^")
     )

    (else
     (string-append 
      (to-modula-proc-name type env) "(" value ")"))
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (array-dimensions type)
  (case (car type)
    ((OpenArray)
     (cons (extract-field 'CARDINAL the-basetypes)
           (array-dimensions (extract-field 'element type))))
    ((Array)
     (cons (extract-field 'index type)
           (array-dimensions (extract-field 'element type))))
    (else '())))

(define (skip n lst)
  (if (= n 0) 
      lst
      (skip (- n 1) (cdr lst))))

(define (make-assigner specified-indices array-type env)

  (define (first-elem d arr)
    (if (= d 0) 
        arr
        (let ((next (first-elem (- d 1) arr)))
          (string-append 
           next "[FIRST(" next ")]"
           ))))

  (define (check-dims n)
    ;; checks one more than n.  n is the dims to "traverse" before checking
    (if (< n 0) 
        ""
        (string-flatten
         (check-dims (- n 1))
         "      IF NUMBER("(first-elem n "tgt")") # NUMBER("(first-elem n "src")") THEN" dnl
         "        RAISE Scheme.E(\"array shape mismatch\")" dnl
         "      END;" dnl
         ))
    )

  (define (reduce-dimension atype n)
    (if (= n 0) 
        atype 
        (reduce-dimension (extract-field 'element atype) (- n 1))))

  (let* ((dims (array-dimensions array-type))
         (assigner-type (reduce-dimension array-type specified-indices))
         (tn (type-formatter assigner-type env))
         (dims-to-traverse (- (length dims) specified-indices 1))
         )
    (string-flatten
     "  PROCEDURE Assign"specified-indices"(VAR tgt : " tn "; READONLY src : " tn ") " 

     (if (= -1 dims-to-traverse) 
         "" 
         "RAISES { Scheme.E } ") 

     "= " dnl
     "    BEGIN" dnl
     "      (* max. dims-to-traverse = " dims-to-traverse " *)" dnl
     (check-dims dims-to-traverse)
     "      tgt := src" dnl
     "    END Assign"specified-indices";" dnl
     dnl
     )
    )
  )


(define (make-assigners array-type env)
  (let loop ((d (length (array-dimensions array-type))))
    (if (< d 0) 
        ""
        (string-flatten (make-assigner d array-type env)
                        (loop (- d 1))))
    ))


(define (visible-what what)
  (let ((res '()))
    (set! res
          (lambda(obj-type)
            ;; a type can only have methods if its opaque or object
            (if (null? obj-type) 
                (make-symbol-hash-table 100)

                (case (car obj-type)
                  ((Ref)
                   (let ((target (extract-field 'target obj-type))
                         (res (make-symbol-hash-table 100)))
                     (if (not (eq? (car target) 'Record))
                         (error "Cant get " what " from " obj-type))
                     (map (lambda(m)
                            (res 'update-entry!
                                 (extract-field 'name m)
                                 m))
                          (extract-field what target))
                     res))

                  ((Object)
                   (let ((super-visible 
                          (res (extract-field 'super obj-type))))
                     (map 
                      (lambda(m)
                        (super-visible 'update-entry!
                                       (extract-field 'name m)
                                       m))
                      
                      (extract-field what obj-type))
                     super-visible))

                  ((Opaque)
                   (res (extract-field 'revealedSuperType obj-type)))

                  (else (error "Cant get " what " from " obj-type))))))
    res))

(define visible-methods (visible-what 'methods))

(define visible-fields (visible-what 'fields))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; (make-procedure-call-stub (car the-procs) global-env)

(define (wrap-procedure p)
	(let* ((sig (extract-field 'sig p))
				 (have-return 
					(if (null? (extract-field 'result sig)) 
							#f
							(extract-field 'result sig)))
				 (intf (extract-field 'intf (car p)))
				 (item (extract-field 'item (car p))))
		
		(define (format-punt-call) 
			(let ((vars (map 
									 (lambda(f)(extract-field 'name f)) 
									 (extract-field 'formals sig))))
				(string-append
				 "      " (if have-return "RETURN " "") intf"."item"("
				 (infixize vars ", ") ")" dnl
				 
				 )
				)
			)

		(string-flatten
		 "PROCEDURE " item (format-parenthesized-signature sig global-env) " =" dnl
		 "  BEGIN" dnl
		 "    SchedulerIndirection.DisableSwitching();" dnl
		 "    TRY" dnl
		 (format-punt-call)
		 "    FINALLY" dnl
		 "      SchedulerIndirection.EnableSwitching()" dnl
     "    END" dnl
		 "  END " item ";" dnl 
		 dnl)))
		
(define (proto-procedure p)
	(let* ((sig (extract-field 'sig p))
				 (have-return 
					(if (null? (extract-field 'result sig)) 
							#f
							(extract-field 'result sig)))
				 (intf (extract-field 'intf (car p)))
				 (item (extract-field 'item (car p))))
		
		(string-flatten
		 "PROCEDURE " item (format-parenthesized-signature sig global-env) ";" dnl
		)))


(define (alias-type t env)
	(string-flatten
	 "TYPE " (cdr (get-alias t)) " = " (format-type t env) ";" dnl))


(define (write-files intf-name procs types env)
  (let* ((proc-stubs (map wrap-procedure procs))
				 (proc-protos (map proto-procedure procs))
				 (type-aliases ;; (map (lambda(t)(alias-type t env)) types)
					'())
											 
         (im (spit-out intf-name proc-stubs proc-protos type-aliases types env))
         (iwr (open-output-file (string-append intf-name ".i3")))
         (mwr (open-output-file (string-append intf-name ".m3"))))

    (display (car im) iwr)
    (display (cdr im) mwr)
    
    (close-output-port iwr) (close-output-port mwr)

    proc-stubs
    ))

(define (stale-output? intf-name)
  (if config-check-staleness
      (let ((stale #f)
            (srcs the-sourcefiles)
            (tgts (map (lambda(sfx)(string-append intf-name sfx)) '(".i3" ".m3"))))
        
        (unwind-protect
         (set! stale (< (apply min (map fs-status-modificationtime tgts))
                        (apply max (map fs-status-modificationtime srcs))))
         '()
         (set! stale #t))
        stale)
      #t))

(define (rename-if-different root1 root2)
  (define (cmp-files-safely fn1 fn2)
    (let ((res #f))
      (unwind-protect
       (set! res (cmp-files fn1 fn2)) #f #f)
      res))

  (define (rename-file-if-different fn1 fn2)
    (if (not (cmp-files-safely fn1 fn2)) (fs-rename fn1 fn2)))
  
  (rename-file-if-different (string-append root1 ".i3") (string-append root2 ".i3"))
  (rename-file-if-different (string-append root1 ".m3") (string-append root2 ".m3"))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;                           ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;   m3build/cm3  helpers    ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;       (extra stuff)       ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;                           ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (strip-extension sym)
  (string->symbol
   (car (pregexp-split "\\." 
                       (symbol->string sym)))))

