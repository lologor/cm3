;;
;; $Id$
;;
;;
;; Process Modula-3 interfaces in Scheme
;;
;; 
;; Copyright (c) 2009, 2010, Generation Capital Ltd.  All rights reserved.
;;
;; Author : Mika Nystrom <mika@alum.mit.edu>
;;

(require-modules "basic-defs" "display" "hashtable" "struct" "set" 
                 "pregexp/pregexp")

;;
;; Stub generator for Scheme / Modula-3 inter-operation
;;
;; The system operates in three phases.
;;
;; phase 1.  make-standard-stuff
;;     Generate Modula-3/Scheme stubs for individual M3 interfaces.
;;     Makes a number of .m3/.i3 files, one per invocation of program.
;;     sstubgen is normally invoked once per existing M3 interface
;;     in this mode.
;;
;; phase 2.  write-scheme-package-exports
;;     Generate exports from a package.  sstubgen is normally invoked
;;     once per package in this mode.  Output is normally written to
;;     an interface with a special, recognizable name.  Due to 
;;     Modula-3's naming rules, the interface name does however have
;;     to be unique, so a good idea is to combine the package name
;;     with a special, recognizable string.
;;
;; phase 3.  make-global-scheme-stubs
;;     Pull in all the exports from all the other packages into an
;;     executable.  You'll need to remember the magic string provided
;;     in phase 2.
;;
;; Normally phases 1-3 are automated by a .tmpl file provided
;; with sstubgen, schemestubs.tmpl.  Look there for more info about
;; how to call this code from cm3 or m3build.
;;

;;
;; Dependencies.  The code in this file depends on (at least) the
;;                following Modula-3 interfaces.
;;
;;   TypeTranslator
;;   ValueTranslator
;;      [which depend on]
;;        Type   (generated by AstToType)
;;        Value  (generated by AstToValue)
;;          [which depend on]
;;             AST interfaces in m3tk
;;
;; Utility functions for conversion to and from Modula are
;; in SchemeProcedureStubs.
;;
;; calling conventions are defined by Main.m3 in the sstubgen/program
;; directory.
;;
;; The following lists are assumed to exist on startup:
;;
;; the-types
;; the-exceptions
;; the-vars
;; the-procs
;; the-consts
;; the-protos
;; the-basetypes
;; the-sourcefiles
;;
;;  ;;;   explanation of individual variables   ;;;
;;
;; the-types
;;     s-expressions for each of the types mentioned in the interface
;;
;; the-exceptions
;;     s-expressions for each of the exceptions mentioned in the interface
;;
;; the-vars
;;     s-expressions for each of the variables declared in the interface
;;
;; the-procs
;;     s-expressions for each of the procedures declared in the interface
;;
;; the-consts
;;     s-expressions for each of the constants declared in the interface
;;
;; the-protos
;;     s-expressions for empty type expressions as declared in Type 
;;     interface
;;
;; the-basetypes
;;     s-expressions for the Modula-3 base types
;;
;; the-sourcefiles
;;     list of filenames for interfaces processed.  Normally just one
;;     filename, if the Quake template has been used.
;;

;; special constants

(define *integer-type*  (assoc 'INTEGER the-basetypes))
(define *first-integer* (cddr (assoc 'min *integer-type*)))
(define *last-integer* (cddr (assoc 'max *integer-type*)))

(define (my-number->string num)
  ;; CM3 compiler can't read the literal for FIRST(INTEGER) number
  ;; we do LAST(INTEGER) as well for symmetry and prettier output code
  (cond ((= num *first-integer*)   "FIRST(INTEGER)")
        ((= num *last-integer*)    "LAST(INTEGER)") 
        (else (number->string num))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;       ENTRY POINTS         ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;      FOR CM3/M3BUILD       ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define (make-standard-stuff intf-name)
  ;;
  ;; phase 1 of stub generation.  
  ;; build all the Scheme stubs for a given M3 interface
  ;;
  (if (stale-output? intf-name) 
      (begin
        (set! global-env (env-type 'new))
        (write-files intf-name the-procs the-types global-env)
        )
      (dis "Scheme stubs up to date: " intf-name dnl))
  )

(define (force-string s)
  (if (symbol? s) (symbol->string s) s))

(define (write-scheme-package-exports 
         intfs      ;; list of interfaces we want to export
         intf-name  ;; name of interface in which to export them
         intf-file-root ;; filename to which to write interface
         )
  ;;
  ;; phase 2 of stub generation.
  ;; Generate exports into the intf-name file.
  ;;
  ;; example.
  ;;
  ;; (define scm-intfs '( BubbleSchemeStubs ExampleSchemeStubs 
  ;;                      FmtSchemeStubs WrSchemeStubs TextWrSchemeStubs 
  ;;                      TextRdSchemeStubs FileWrSchemeStubs RdSchemeStubs 
  ;;                      FileRdSchemeStubs PickleSchemeStubs 
  ;;                      MarketDataSchemeStubs TextSetSchemeStubs 
  ;;                      TextSetDefSchemeStubs))
  ;;
  ;; (write-scheme-package-exports scm-intfs "stubexample__SCHEMEEXPORTS__" "stubexample__SCHEMEEXPORTS__")
  ;;

  (let* ((iwr (open-output-file (string-append intf-file-root ".i3")))
         (mwr (open-output-file (string-append intf-file-root ".m3"))))

    (dis 
     (string-append
      "INTERFACE "intf-name";" dnl
      "(* AUTOMATICALLY GENERATED DO NOT EDIT *)" dnl
      "PROCEDURE RegisterStubs();" dnl
      "END " intf-name "." dnl
      )
     iwr
     )

    (dis 
     (string-append
      "MODULE "intf-name";" dnl
      "(* AUTOMATICALLY GENERATED DO NOT EDIT *)" dnl
      (if (null? intfs) 
          "" 
          (string-append "IMPORT " (infixize intfs ", ") ";" dnl))
      dnl
      "PROCEDURE RegisterStubs() =" dnl
      "  BEGIN" dnl
      (apply string-append
             (map (lambda(i)(string-append "    " i ".RegisterStubs();" dnl))
                  intfs)
             )
      "  END RegisterStubs;" dnl
      dnl
      "BEGIN END " intf-name "." dnl
      )
     mwr
     )

    (close-output-port iwr) (close-output-port mwr)
    ))


(define (make-global-scheme-stubs magic-string  ;; what to search for
                                  search-path   ;; path of IMPTAB
                                  output-intf   ;; name of intf/impl
                                  output-root   ;; where to write
                                  .
                                  local-exports ;; if were exporting from
                                  ;; current package
                                  )

  ;;
  ;; phase 3 of Scheme stub generation
  ;; called before building an executable.  Pull in stubs from
  ;; all visible packages.
  ;;
  ;; example.
  ;; (make-global-scheme-stubs 
  ;; "__SCHEMEEXPORTS__"             ;; special string we recognize
  ;; ".M3IMPTAB"                     ;; where to look
  ;; "SchemeStubs"                   ;; what to call result
  ;; "stubexample__SCHEMEEXPORTS__"  ;; from current package
  ;; )
  ;;

  (let ((in (open-input-file search-path)))
    
    (define (get-matches)
      (let loop ((next (read in))
                 (res '()))
        ;;                 (res local-exports))
        (if (eof-object? next) 
            res
            (begin
              ;;(dis "matching against " next dnl)
              (let ((match (string-havesub? (symbol->string next)
                                            magic-string)))
                (if match 
                    (loop (read in) (cons (strip-extension next) res))
                    (loop (read in) res)))))))
    
    (write-scheme-package-exports   (uniq equal? (map force-string 
                                                      (append (get-matches) local-exports)))
                                    output-intf output-root)

    (close-input-port in))
  
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;      CONFIGURATIONS        ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define config-check-staleness #t)
;; set this to #t to check file staleness before rebuilding,
;; otherwise rebuilding "always" happens

(define (reload) (load "../../program/src/sstubgen.scm"))
;; utility function for interactive testing

(set-warnings-are-errors! #t)
;; for debugging


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;      INTERNAL REPS         ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-type-name interface name) (cons interface name))

(define (extract-field  field-name type)
  (let ((ass (assoc field-name type)))
    (if (not (pair? ass))
        (error "No assoc for " field-name " in " type)
        (cdr ass))))

(define (have-field? field-name type)
  (assoc field-name type))

(define (type-type type) (car type))

(define (get-alias type) 
  (if (not (have-field? 'alias type)) '()
      (let ((qid (extract-field 'alias type)))
        (if (null? qid) 
            '()
            (cleanup-qid qid)))))

(define (get-name type) 
  (if (not (have-field? 'name type)) '()
      (let ((qid (extract-field 'name type)))
        (if (null? qid) 
            '()
            (cleanup-qid qid)))))

(define (cleanup-qid qid)
  (if (= 0 (string-length (symbol->string (extract-field 'intf qid))))
      (cons '() (extract-field 'item qid))
      (cons (extract-field 'intf qid)
            (extract-field 'item qid))))

(define (string-type-alias type sep env)
  (let ((tn (get-alias type)))
    (stringify-qid tn sep env)))

(define (string-type-name type sep env)
  (let ((tn (get-name type)))
    (stringify-qid tn sep env)))

(define (stringify-qid tn sep env)
  (if (not (pair? tn))
      (error "stringify-qid : not a pair : " tn))

  (if (not (or (null? (car tn)) (symbol? (car tn))))
      (error "stringify-qid : car is not a symbol or null : " tn))

  (if (not (symbol? (cdr tn)))
      (error "stringify-qid : cdr is not a symbol : " tn))

  (if (or (null? (car tn))
          ((env 'get 'exports) 'member? (car tn)))
      (symbol->string (cdr tn))
      (begin
        ((env 'get 'imports) 'insert! (car tn))
        (string-append (symbol->string (car tn))
                       sep
                       (symbol->string (cdr tn))))))

(define (find-type-alias named types)
  (car 
   (filter (lambda (t) (equal? (get-alias t) named))
           types)))

(define (find-named-element named lst)
  (let ((matches (filter 
                  (lambda (t) (equal? (extract-field 'name t) named))
                  lst)))
    (if (null? matches) 
        (error "find-named-element: no matches : " named " " lst))
    (if (not (null? (cdr matches)))
        (error "find-named-element: multiple matches : " named " " lst))
    (car matches)))

;; subranges
(define (base-type-type type) (type-type (base-type type)))

(define (base-type type)
  (if (not (eq? (car type) 'Subrange))
      (error "cant get base type of " (car type))
      (let ((base (extract-field 'base type)))
        (cond ((eq? (type-type base) 'UserDefined) base)
              ((eq? type base)       base) ;; integer
              (else (base-type base))))))

(define (intersperse lst sep)
  ;; this routine MUST BE tail-recursive, or we will definitely
  ;; run out of stack space!
  (define (helper lst so-far)
    (cond ((null? lst) so-far)
          ((null? (cdr lst)) (cons (car lst) so-far))

          (else 
           (helper (cdr lst) 
                   (cons sep  (cons (car lst) so-far))))))
  (reverse (helper lst '()))
  )

(define (infixize string-list sep)
  (if (null? string-list) ""
      (apply string-append 
             (intersperse string-list sep))))

(define (formals-from-sig sig)
  (filter (lambda(f) (and (pair? f) (eq? (car f) 'Formal)))
          (assoc 'formals sig)
          ))

(define (format-formal-param f)
  (symbol->string (extract-field 'name f)))

(define (format-formal-decl f env)
  (let ((name (extract-field 'name f))
        (mode (extract-field 'mode f))
        (type (extract-field 'type f)))
    (string-append
     (case mode
       ((Mode.Var) "VAR ")
       ((Mode.Value) "VALUE ")
       ((Mode.Readonly) "READONLY ")
       (else (error "unknown mode " mode)))
     (symbol->string name)
     " : "
     (format-type type env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;       FORMAT TYPES         ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define bad-type '())

(define (format-object-super t env)
  (let ((super (extract-field 'super t)))
    (if (null? super) "" (format-type super env))))

(define (format-branding t)
  (if (extract-field 'branded t)
      (string-append " BRANDED " 
                     (let ((brand (extract-field 'brand t)))
                       (if (null? brand) "" (string-append "\"" brand "\""))))
      ""))

(define (format-field f env)
  (let ((type (extract-field 'type f)))
    (string-append
     (extract-field 'name f)
     " : "
     (format-type type env)
     (let ((default (extract-field 'default f)))
       (if (not (null? default))
           (string-append " := " (format-type-value type default env))
           "")))))

(define (format-fields t env)
  (apply string-append 
         (map 
          (lambda(fld) (string-append "    " (format-field fld env) ";" dnl))
          (extract-field 'fields t))))

(define (extract-and-format-qid d env)
  (let* ((qid (extract-field 'qid d))
         (intf (extract-field 'intf qid))
         (item (extract-field 'item qid)))
    (stringify-qid (cons intf item) "." env)))

(define (format-formal f env) 
  (let ( (mode (extract-field 'mode f)) )
    (string-append
     (case mode
       ((Mode.Var) "VAR ")
       ((Mode.Value) "VALUE ")
       ((Mode.Readonly) "READONLY ")
       (else (error "unknown mode " mode)))
     (format-field f env))))

(define (format-exceptions x env)
  (infixize (map (lambda(xx)(extract-and-format-qid xx env)) x) ", "))

(define (format-parenthesized-signature sig env . optional-me)

  ;; format a procedure (or method) signature
  (string-append 
   "("
   (infixize  (append optional-me 
                      (map (lambda(x)(format-formal x env)) 
                           (extract-field 'formals sig))) "; ")
   ")"

   (let ((result (extract-field 'result sig)))
     (if (null? result) ""
         (string-append " : " (format-type result env))))

   (let ((raises (extract-field 'raises sig)))
     ;; note the distinction here.
     ;; raises null : raises ANY
     ;; a null list : raises {}
     ;; else.. the exceptions listed
     (cond ((null? raises) " RAISES ANY")
           ((and (pair? raises) (null? (car raises))) "")
           (else (string-append " RAISES { "
                                (format-exceptions (car raises) env)
                                " }"))))))

(define (format-method m env)
  (let ((name (extract-field 'name m))
        (sig (extract-field 'sig m))
        (default (extract-field 'default m)))
    (string-append "    " name (format-parenthesized-signature sig env)
                   (if (not (null? default)) 
                       (string-append " := " (extract-and-format-qid default env) )
                       ""))
    ))

(define (format-object-methods t env)
  (apply string-append 
         (map 
          (lambda(f) (string-append (format-method f env) ";" dnl))
          (extract-field 'methods t))))

(define (format-override m env)
  (let ((name (extract-field 'name m))
        (default (extract-field 'default m)))
    (string-append "    " name " := " (extract-and-format-qid default env) )

    ))

(define (format-object-overrides t env)
  (apply string-append 
         (map 
          (lambda(f) (string-append (format-override f env) ";" dnl))
          (extract-field 'overrides t))))

(define (unprotected-format-type t env)
  (cond ((is-basetype t) => 
                         (lambda(x)(string-append " " (symbol->string x) " ")))
        ((have-field? 'alias t) (string-type-alias t "." env))
        ((and (have-field? 'name t)(not (null? (extract-field 'name t)))) 
         (string-type-name t "." env))
        (else 
         (case (car t)
           ((Ref)
            (string-append " REF " (type-formatter 
                                    (extract-field 'target t)
                                    env
                                    )))

           ((Subrange)
            (let ((base (type-formatter (extract-field 'base t) env)))
              (string-append "[ VAL("(cdr (extract-field 'min t))  "," base ")"
                             ".."
                             "VAL("(cdr (extract-field 'max t))  "," base ") ]")
              ))

           ((OpenArray)
            (string-append 
             " ARRAY OF " 
             (type-formatter (extract-field 'element t) env)
             ))
           
           
           ((Array)
            (string-append
             " ARRAY " 
             (type-formatter (extract-field 'index t) env)
             " OF "
             (type-formatter (extract-field 'element t) env)
             )
            )

           ((Set)
            (string-append
             " SET OF " (type-formatter (extract-field 'range t) env)))

           ;; do we really want CHAR and WIDECHAR here?
           ((Char) " CHAR")
           
           ((WideChar) " WIDECHAR")

           ((Object)
            (string-append 
             (format-object-super t env)
             (format-branding t)
             " OBJECT" dnl
             (format-fields t env)
             " METHODS" dnl
             (format-object-methods t env)
             " OVERRIDES" dnl
             (format-object-overrides t env)
             " END" dnl))

           ((UserDefined) 
            (string-append " { " 
                           (infixize (extract-field 'elts t) ", ")
                           " } " dnl))

           ((Record)
            (string-append
             " RECORD " dnl
             (format-fields t env)
             " END" dnl))

           ((Procedure)
            (string-append
             " PROCEDURE"
             (format-parenthesized-signature (extract-field 'sig t) env)))

           ((Packed)
            (string-append " BITS " (extract-field 'size t) " FOR " (format-type (extract-field 'base t) env)))

           ((Opaque)
            (string-append
             " (* <: *) " (format-branding t) dnl
             (type-formatter (extract-field 'revealedSuperType t) env) dnl))

           (else (error "format-type: dont know how to format " t)))))
  )

(define (strip-names type)
  (filter-out '(alias name) type))

(define (format-type t env)
  (unwind-protect
   (unprotected-format-type t env)
   () ;; finally-clause
   (begin
     (set! bad-type t) ;; remember for debugging
     (error "format-type caught error formatting " t dnl dnl))))

(define type-formatter format-type)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;       FORMAT VALUES        ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;                            ;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define bad-values '())

(define (is-reference-type? type)
  (member? (car type) '(Opaque Ref Procedure Object)))

(define (format-type-value type value env)
  (case (car value)

    ((Ordinal) 
     ;; special case for NIL: (Ordinal . 0)
     
     (if (is-reference-type? type)
         (if (not (= (cdr value) 0))
             (error "Ordinal initializer for Ref, non-zero value : " type 
                    ", " value)
             " NIL")
         (string-append 
          " VAL(" 
          (my-number->string (cdr value))", "  (type-formatter type env)
          ")")))
    
    ((LongFloat)
     (string-append
      " FLOAT("
      (number->LONGREAL (cdr value))
      ", "
      (type-formatter type env)
      ")"
      ))

    ((Float)
     (string-append
      " FLOAT("
      (number->REAL (cdr value))
      ", "
      (type-formatter type env)
      ")"
      ))

    ((Extended)
     (string-append
      " FLOAT("
      (number->EXTENDED (cdr value))
      ", "
      (type-formatter type env)
      ")"
      ))

    ((Proc) (stringify-qid (cleanup-qid (cdr value))
                           "."
                           env))

    ((Set)
     (string-append
      " " (type-formatter type env)
      " { "

      (infixize 
       (map (lambda(m)(format-set-member m type env)) (cdr value))
       ", ")

      " } "))
    
    ((Txt)
     (string-append "\"" (cdr value) "\""))

    ((ArrayOrRecord)

     (string-append
      " " (type-formatter type env)
      " { "
      (infixize
       (let loop ((i 0)
                  (elements (cdr value)))
         (if (null? elements) 
             '()
             (cons (format-element (car elements) type i env)
                   (loop (+ i 1) (cdr elements) ))))
       ", ")
      " } " dnl))

    (else
     (set! bad-values (cons (cons type value) bad-values))
     "**NOTYET**")
    ))

(define (format-set-member m set-type env)
  ;; format the initializer for a set member
  (format-type-value (extract-field 'range set-type) m env))

(define (format-element e container-type index env)
  ;; format the initializer of a single item in an ARRAY or RECORD
  ;; dispatches on the container type
  (case (car container-type)

    ((Record) 
     (format-record-element e container-type index env))

    ((OpenArray Array) 
     (format-array-element e container-type index env))
    
    (else (error "cant format element of " (car container-type)))))

(define (format-array-element e container-type index env)
  ;; format the initializer for an array element
  (case (car e)
    ((Propagate) " .. ")
    
    ((Range) 
     (let* ((elem-valu (cdr e))
            (elem-type (extract-field 'element container-type)))
       (string-append 
        " "
        (format-type-value elem-type elem-valu env)
        )))
    
    (else (error "unknown element type " (car e)))
    ))


(define (format-record-element e container-type index env)
  ;; format the initializer for a record member
  (case (car e)
    ((Actual) 
     (let* ((field-name (cadr e))
            (field-valu (caddr e))
            (field-desc (find-named-element 
                         field-name (extract-field 'fields container-type)))
            (field-type (extract-field 'type field-desc)))
       (string-append
        " "
        field-name
        " := " 
        (format-type-value field-type field-valu env)
        
        )
       
       ))
    
    ((Range) 
     (let* ((field-valu (cdr e))
            (field-desc (nth (extract-field 'fields container-type) index))
            (field-type (extract-field 'type field-desc)))
       (string-append 
        " "
        (format-type-value field-type field-valu env)
        )))
    
    (else (error "unknown element type " (car e)))
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (filter-out keys struct)
  (filter
   (lambda (x) (or (not (pair? x))(not (memq (car x) keys))))
   struct))

(define (lp xx)
  ;; "line printing"

  (begin 
    (map (lambda(x) (dis x dnl)) xx) 
    #t))

(define (lp2 xx)
  (begin
    (map (lambda(x) (begin (lp x)(dis "----------------------" dnl)) #t) xx)
    #t
    ))

(define (make-pair-hash-table size) ;; silly
  (define (pair-hash p) 0)
  (make-hash-table size pair-hash))

(define env-type 
  (make-struct-type
   'env-type
   `((exports       ,(lambda()(make-symbol-set 100))) 
     ;; interfaces we export

     (imports       ,(lambda()(make-symbol-set 100))) 
     ;; interfaces we need to import

     (symbols       ,(lambda()(make-symbol-set 100)))
     ;; symbols we need to build at load time for runtime comparison,
     ;; against method names, exception names, etc.

     (convert->m3-req          ,(lambda()(make-symbol-hash-table 100))) 
     ;; converters->m3 requested

     (convert->scm-req          ,(lambda()(make-symbol-hash-table 100))) 
     ;; converters->scm requested

     (convert-blt          ,(lambda()(make-symbol-set 100))) 
     ;; converters built

     (procedure-call-stubs ,(lambda()(make-pair-hash-table 100))) 
     ;; procedure call stubs built

     )))

(define global-env (env-type 'new))

(define (global-format t)
  (begin
    (set! global-env (env-type 'new))
    (format-type t global-env)
    ))

(define (init-symbol-set . syms)
  (let ((res (make-symbol-set 100)))
    (map (lambda(x)(res 'insert! x)) syms)
    res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (format-arbitrary-identifier sym)
  ;; convert . to DOT
  (string-append
   "SYMBOL_"
   (list->string
    (apply append 
           (map (lambda(c)(if (eq? c #\.) (string->list "DOT") (list c)))  
                (string->list (force-string sym)))))))

(define (make-symbol from env) ;; equivalent to SchemeSymbol.FromText(sym)
  (let ((sym (cond ((string? from) (string->symbol from))
                   ((symbol? from)                 from )
                   (else ("error not string or symbol" from)))))
    ((env 'get 'symbols) 'insert! sym)
    ;;(string-append "SchemeSymbol.FromText(\"" sym "\")")
    ;; basic version

    (string->symbol (format-arbitrary-identifier from)) ;; optimized version
    
    )
)

(define (format-symbols symbol-list)
  (apply 
   string-append
   (map (lambda(ident)
          (string-append
           "VAR " (format-arbitrary-identifier ident)
           " := SchemeSymbol.FromText(\"" ident "\");" dnl))
        symbol-list)))

(define (format-load-time-symbols env)
  (format-symbols ((env 'get 'symbols) 'keys)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (format-const-value c env) ;; format constant from global env 
  (format-type-value
   (extract-field 'type c)
   (extract-field 'value c)
   env
   ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; test code
(set! type-formatter unprotected-format-type)
;;(map global-format (map strip-names the-types))

(define (m3type->m3identifier s)
  ;;
  ;; turn a legal Modula-3 type specifier into a legal Modula-3 identifier
  ;; (by hook or by crook)
  ;;
  (list->string
   (filter 
    (lambda (c) (or (char=? c #\_)
                    (char-alphabetic? c)
                    (char-numeric? c)))
    (map 
     (lambda (c) (cond ((char=? c #\.) #\_)
                       (else c)))
     (string->list s)))))

(define (to-scheme-proc-name type env)
  ;;
  ;; if it's a base type, we call the base type conversion library
  ;; else we make the converter ourselves.
  ;;
  (if (and (is-basetype type) 
           (eq? (scheme-modula-conversion-mode (is-basetype type))
                'Concrete))
      (begin
        (stringify-qid
         (cons 'SchemeModula3Types
               (string->symbol (string-append "ToScheme_" (is-basetype type))))
         "."
         env))
      (let ((convert-req (env 'get 'convert->scm-req))
            (res 
             (string-append "ToScheme_" 
                            (m3type->m3identifier (type-formatter type env)))))
        (convert-req 'update-entry! (string->symbol res) type)
        res)))

(define (is-basetype type)
  ;; returns string name of basetype or #f

  (define (is-opaque-basetype)
    ;; special handling for opaques, by name
    (let loop ((p the-basetypes))
      (cond ((null? p) #f)
            ((equal? (cdar p) type) (caar p))
            (else (loop (cdr p))))))

  

  (cond ((eq? 'Opaque (car type)) (is-opaque-basetype))
        ((equal? type (cdr (assoc 'ADDRESS the-basetypes))) 'ADDRESS)
        (else (let ((unnamed-type (strip-names type)))
                (let loop ((p the-basetypes))
                  (cond ((null? p) #f)
                        ((equal? (strip-names (cdar p)) unnamed-type) (caar p))
                        (else (loop (cdr p)))))))))

(define (string-quote s) (string-append "\"" s "\""))

(define (format-imports env)
  (let ((keys ((env 'get 'imports) 'keys)))
    (if (null? keys) 
        ""
        (apply string-append
               (map (lambda (i) 
                      (string-append 
                       "IMPORT " i ";" dnl)) 
                    keys)))))

(define (make-modules name              ;; name of interface
                      interface-decls   ;; stuff for .i3
                      module-decls      ;; stuff for .m3
                      module-code       ;; initialization block
                      env)
  (if (not (env 'get 'exports) 'member? name)
      (error "not member of exports : " name))
  (string-append
   "MODULE " name ";" dnl

   (format-imports env)

   dnl
   module-decls
   dnl
   "BEGIN" dnl
   module-code 
   "END " name "." dnl))

(define (make-to-scheme-nonbase type env)

  (define (push-make type)(to-scheme-proc-name type env))

  (let* ((m3tn                       ;; type name
          (type-formatter type env))

         (m3ti                       ;; identifier mangled from tn
          (m3type->m3identifier (type-formatter type env)))

         (pname (to-scheme-proc-name type env))

         (imports (env 'get 'imports))

         (proto (string-append
                 "PROCEDURE " pname "(READONLY x : " m3tn 
                 ") : SchemeObject.T RAISES {"
                 (if (member? (car type) '(Ref Procedure Object Opaque))
                     ""
                     " Scheme.E")
                 " }"
                 )
                )
         )

    (if (is-basetype type) (error "shouldnt call make-to-scheme-nonbase on base type" type))

    ((env 'get 'convert-blt) 'insert! (string->symbol pname))
    ;; remember that we're building pname, so we dont try to
    ;; build it recursively
    

    (imports 'insert! 'SchemeObject) 
    (imports 'insert! 'Scheme)
    (imports 'insert! 'SchemePair)

    (define (make-intf) (string-append proto ";"))

    (define (make-impl)
      (imports 'insert! 'SchemePair)
      (string-append
       proto " = " dnl
       "  BEGIN" dnl

       "    "
       (case (car type)

         ((Ref)
          ;; canonical rep. of a Modula-3 ref is just the ref itself,
          ;; unless its UNTRACED.
          (if (extract-field 'traced type)
              "RETURN x"
              (string-flatten
               "RETURN NEW(REF RECORD ref : " m3tn " END, ref := x)")
              ))
         
         ((Record)
          (map 
           (lambda(i)(imports 'insert! i))
           '(SchemeUtils SchemePair SchemeUtils SchemeSymbol))

          (let ((fields (extract-field 'fields type)))

            (define (format-field f)
              (let* ((field-name (extract-field 'name f))
                     (field-type (extract-field 'type f))
                     (field-pname (push-make field-type)))
                (string-append 
                 "      res := SchemeUtils.Cons(SchemeUtils.Cons(" 
                 (make-symbol field-name env) 
                 "," field-pname "(x." field-name ")),res)")))

            (string-append
             "VAR res : SchemePair.T:=NIL; BEGIN" dnl 
             (infixize (map format-field fields) (string-append ";" dnl)) ";" dnl
             "      RETURN res" dnl
             "    END" 
             )

            )
          )

         ((UserDefined) 
          (let ((elts (extract-field 'elts type)))
            (define (elts-names) 
              (infixize (map string-quote (map symbol->string elts)) ", ")
              )

            (imports 'insert! 'SchemeSymbol)
            (string-append 
             "CONST" dnl
             "      Name = ARRAY " m3tn " OF TEXT { " (elts-names) " }; " dnl
             "    BEGIN" dnl
             "      RETURN SchemeSymbol.FromText(Name[x])" dnl
             ;; preallocating these would be overoptimizing, I think
             "    END" 
             )
            )
          )

         ((Packed)
          (let* ((base (extract-field 'base type))
                 (base-pname (push-make base)))
            (string-append
             "RETURN " base-pname "(x)" 
             )
            )
          )

         ((Subrange)
          (let* ((base (extract-field 'base type))
                 (base-pname (push-make base)))
            (string-append
             "RETURN " base-pname "(x)" 
             )
            )
          )

         ((Array)
          (let* ((element (extract-field 'element type))
                 (element-pname (push-make element))
                 (index (extract-field 'index type))
                 (index-pname (push-make index))
                 )
            (imports 'insert! 'SchemePair)
            (imports 'insert! 'SchemeUtils)
            (string-append
             "VAR res : SchemePair.T:=NIL; BEGIN" dnl 
             
             "      FOR i := LAST(x) TO FIRST(x) BY -1 DO" dnl
             "        res := SchemeUtils.Cons(SchemeUtils.Cons(" index-pname "(i)," element-pname "(x[i])), res)" dnl
             "      END;" dnl
             "      RETURN res"
             "    END"))
          

          )

         ((OpenArray)
          (let* ((element (extract-field 'element type))
                 (element-pname (push-make element)))
            (imports 'insert! 'SchemePair)
            (imports 'insert! 'SchemeUtils)
            (string-append
             "VAR res : SchemePair.T:=NIL; BEGIN" dnl 
             "      FOR i := LAST(x) TO FIRST(x) BY -1 DO" dnl
             "        res := SchemeUtils.Cons(" element-pname "(x[i]), res)" dnl
             "      END;" dnl
             "      RETURN res" dnl
             "    END"))
          
          )

         ((Set)
          (let* ((range-type (extract-field 'range type))
                 (range-name (type-formatter range-type env))
                 (range-pname (push-make range-type)))
            (string-append
             "VAR res : SchemePair.T:=NIL; BEGIN" dnl
             "      FOR i := FIRST("range-name") TO LAST("range-name") DO" dnl
             "        IF i IN x THEN" dnl
             "          res := SchemeUtils.Cons(" range-pname "(i), res)" dnl
             "        END" dnl
             "      END;" dnl
             "      RETURN res" dnl
             "    END"
             )
            )
          )

         ;; ((Char) 
         ;;  (imports 'insert! 'SchemeChar)
         ;;  "RETURN SchemeChar.Character(x)" )

         ((Procedure) 
          "RETURN NIL (* conversion not implemented yet, not sure its possible *)" ;; see bug 108
          
          )

         ((Object Opaque)
          "RETURN x" ;; just let it represent itself
          )

         ((WideChar)
          (imports 'insert! 'SchemeModula3Types)
          (string-append
           "WITH ref = NEW(REF WIDECHAR) DO" dnl
           "  ref^ := x;" dnl
           "  RETURN SchemeModula3Types.ToScheme_WIDECHAR(ref)"
           "END"
           )
          )

         (else (error "unknown type header " (car type)))

         )               
       dnl

       "  END " pname ";" dnl
       )
      )
    
    (cons (make-intf) (make-impl))
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (to-modula-proc-name type env)
  ;; if it's a base type, we call the base type conversion library
  ;; else we make the converter ourselves.

  ;; we want to warn early if were trying to do something stupid
  (if (eq? (car type) 'OpenArray)
      (error "dont try to make open array directly from Scheme object, use REF type instead"))

  (if (and (is-basetype type) 
           (eq? (scheme-modula-conversion-mode (is-basetype type))
                'Concrete))
      (begin
        (stringify-qid
         (cons 'SchemeModula3Types
               (string->symbol (string-append "ToModula_" (is-basetype type))))
         "."
         env))
      (let ((convert-req (env 'get 'convert->m3-req))
            (res (string-append 
                  "ToModula_" 
                  (m3type->m3identifier (type-formatter type env)))))
        (convert-req 'update-entry! (string->symbol res) type)
        res)))

(define (make-to-modula-nonbase type env)

  (define (push-make type) (to-modula-proc-name type env))

  (let* ((m3tn                       ;; type name
          (type-formatter type env))

         (m3ti                       ;; identifier mangled from tn
          (m3type->m3identifier (type-formatter type env)))

         (pname (to-modula-proc-name type env))

         (imports (env 'get 'imports))

         (proto (string-append
                 ;; parens around the return type are needed here
                 ;; in case the return type is a PROCEDURE
                 "PROCEDURE " pname "(x : SchemeObject.T) : (" m3tn ")"
                 " RAISES { Scheme.E }"
                 )
                )
         )

    (if (is-basetype type) (error "shouldnt call make-to-modula-nonbase on base type" type))

    ((env 'get 'convert-blt) 'insert! (string->symbol pname))
    ;; remember that we're building pname, so we dont try to
    ;; build it recursively
    

    (imports 'insert! 'SchemeObject) 
    (imports 'insert! 'Scheme)

    (define (make-intf) (string-append proto ";"))

    (define (make-impl)
      (string-append
       proto " = " dnl
       "  BEGIN" dnl
       "    IF x # NIL AND ISTYPE(x, REF " m3tn ") THEN RETURN NARROW(x,REF "m3tn")^ END; " dnl

       (case (car type)

         ((Ref)
          ;; several possibilities.  either we have the correct type
          ;; already, or else we may have to build it, if a Ref OpenArray
          ;; special stuff for UNTRACED at the end
          (if (extract-field 'traced type)
              
              (string-flatten
               "    IF ISTYPE(x, "m3tn") THEN RETURN x END;" dnl

               ;; mika 4/18/2021 only handles 1-D arrays
               ;; we should really fix this as follows:
               ;; 
               ;; if openDimensions > 1, then
               ;;   iterate through the element types until we get to the
               ;;   actual element type
               ;;
               ;;   and in the generated Modula code, make it use an array
               ;;   of CARDINAL indices idx[] instead of a single cardinal i
               
               (let* ((target (extract-field 'target type)))
                 (if (and (eq? (car target) 'OpenArray)
                          (= (extract-field 'openDimensions target) 1))
                     (let* ((element (extract-field 'element target))
                            (element-pname (push-make element)))
                       (string-append
                        "    VAR arr := NEW("m3tn",SchemeUtils.Length(x));" dnl
                        "        p := SchemePair.Pair(x);" dnl      
                        "        i := 0;" dnl
                        "    BEGIN" dnl
                        "      WHILE p # NIL DO" dnl
                        "        arr[i] := "element-pname"(p.first);" dnl
                        "        p := SchemePair.Pair(p.rest);" dnl
                        "        INC(i)" dnl
                        "      END;" dnl
                        "      RETURN arr" dnl
                        "    END;" dnl
                        ))
                     (string-append
                      "    RAISE Scheme.E(\"Not of type "m3tn" : \" & SchemeUtils.Stringify(x))" dnl)))
               )
              
              (string-flatten
               "    TYPE Rec = REF RECORD ref : " m3tn " END;" dnl
               "    BEGIN" dnl
               "      IF NOT ISTYPE(x, Rec) THEN" dnl
               "        RAISE Scheme.E(\"Not of type "m3tn" : \" & SchemeUtils.Stringify(x))" dnl
               "      ELSE" dnl
               "        RETURN NARROW(x,Rec).ref" dnl
               "      END" dnl
               "    END" dnl
               )
              
              )
          )
         
         ((Record)
          (imports 'insert! 'SchemeSymbol)
          
          (let ((fields (extract-field 'fields type)))
            
            (define (format-field f)
              (let* ((field-name (extract-field 'name f))
                     (field-type (extract-field 'type f))
                     (field-pname (push-make field-type)))
                (string-append 
                 "        ELSIF " (make-symbol field-name env) 
                                " = SchemeUtils.First(p.first) THEN" dnl
                 "          res."field-name" := "field-pname"(SchemeUtils.Rest(p.first))" dnl)))
            
            (string-append
             "    VAR res : "m3tn";" dnl
             "        p := SchemePair.Pair(x);" dnl 
             "    BEGIN" dnl 
             "      WHILE p # NIL DO" dnl
             (string-append 
              "        IF FALSE THEN" dnl
              (apply string-append (map format-field fields) )
              "        END;" dnl
              )
             "        p := SchemePair.Pair(p.rest)" dnl
             "      END;" dnl
             "      RETURN res" dnl
             "    END" 
             )
            )
          
          )

         ((UserDefined) 
          (let ((elts (extract-field 'elts type)))
            (define (elts-names) 
              (infixize (map string-quote (map symbol->string elts)) ", ")
              )

            (imports 'insert! 'SchemeSymbol)
            (string-append 
             "CONST" dnl
             "      Name = ARRAY " m3tn " OF TEXT { " (elts-names) " }; " dnl
             "    BEGIN" dnl
             "      FOR i := FIRST(Name) TO LAST(Name) DO" dnl
             "        IF SchemeSymbol.FromText(Name[i]) = x THEN" dnl
             "          RETURN i" dnl
             "        END" dnl
             "      END;" dnl
             "      RAISE Scheme.E(\"Not a value of "m3tn" : \" & SchemeUtils.Stringify(x))" dnl
             "    END"
             )
            )
          )

         ((Packed)
          (let* ((base (extract-field 'base type))
                 (base-pname (push-make base)))
            (string-append
             "    WITH baseVal = " base-pname "(x) DO"  dnl
             "      RETURN baseVal" dnl
             "    END"
             )
            )
          )

         ((Subrange)
          (let* ((base (extract-field 'base type))
                 (base-pname (push-make base)))
            (string-append
             "    WITH baseVal = " base-pname "(x) DO"  dnl
             "      IF baseVal < FIRST("m3tn") OR baseVal > LAST("m3tn") THEN" dnl
             "        RAISE Scheme.E(\"Value out of range for "m3tn" :\" & SchemeUtils.Stringify(x))" dnl
             "      END;" dnl
             "      RETURN baseVal" dnl
             "    END"
             )
            )
          )

         ((Array)
          (let* ((element (extract-field 'element type))
                 (element-pname (push-make element))
                 (index (extract-field 'index type))
                 (index-pname (push-make index))
                 )
            (imports 'insert! 'SchemePair)
            (imports 'insert! 'SchemeUtils)
            (string-append
             "    VAR res : "m3tn"; p := SchemePair.Pair(x); BEGIN" dnl
             "      (* attempt to treat as open array *)" dnl
             "      IF p # NIL AND NOT ISTYPE(p.first, SchemePair.T) THEN" dnl
             "        FOR i := FIRST(res) TO LAST(res) DO" dnl
             "          res[i] := "element-pname"(p.first);" dnl
             "          p := SchemePair.Pair(p.rest);" dnl
             "        END;" dnl
             "        RETURN res" dnl
             "      END;" dnl
             "      WHILE p # NIL DO" dnl
             "        WITH desc = SchemePair.Pair(p.first) DO" dnl
             "          IF desc = NIL THEN " dnl
             "            RAISE Scheme.E(\"NIL pair in \" & SchemeUtils.Stringify(x))" dnl
             "          END;" dnl
             "          res["index-pname"(desc.first)] := "element-pname"(desc.rest)" dnl
             "        END;" dnl
             "        p := SchemePair.Pair(p.rest)" dnl
             "      END;" dnl
             "      RETURN res" dnl
             "    END"))
          )

         ((OpenArray)
          (error "Cant make open array directly from Scheme object, make a REF instead")
          )

         ((Set)
          (let* ((range-type (extract-field 'range type))
                 (range-name (type-formatter range-type env))
                 (range-pname (push-make range-type)))
            (imports 'insert! 'SchemePair)
            (string-append
             "    VAR res := "m3tn" {}; p := SchemePair.Pair(x); BEGIN" dnl 
             "      WHILE p # NIL DO" dnl
             "        res := res + "m3tn" { "range-pname"(p.first) };" dnl
             "        p := SchemePair.Pair(p.rest)" dnl
             "      END;" dnl
             "      RETURN res" dnl
             "    END"
             )
            )
          )

         ((Procedure)
          "     RETURN NIL (* conversion not implemented yet, not sure its possible *)"
          )

         ((Object Opaque) 
          (imports 'insert! 'SchemeConvertHooks)
          (string-append
           "    TYPECASE x OF" dnl
           "      "m3tn"(xx) => RETURN xx" dnl
           "    ELSE" dnl
           "      IF SchemeConvertHooks.AttemptConvertToModula(TYPECODE("m3tn"), x) THEN" dnl
           "        RETURN x" dnl
           "      ELSE" dnl
           "        RAISE Scheme.E(\"Not of type "m3tn" : \" & SchemeUtils.Stringify(x))" dnl
           "      END" dnl
           "    END" dnl
           )
          )

         ((WideChar)
          (imports 'insert! 'SchemeModula3Types)
          "RETURN NARROW(SchemeModula3Types.ToModula_WIDECHAR(x),REF WIDECHAR)^")

         (else (error "unknown type header " (car type)))

         )               
       dnl

       "  END " pname ";" dnl
       )
      )
    
    (cons (make-intf) (make-impl))
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-to-modula-baseref basename env)
  (let* ((type (extract-field basename the-basetypes))
         (m3tn                       ;; type name
          (type-formatter type env))

         (m3ti                       ;; identifier mangled from tn
          (m3type->m3identifier (type-formatter type env)))

         (pname (to-modula-proc-name type env))

         (imports (env 'get 'imports))

         (proto (string-append
                 "PROCEDURE " pname "(x : SchemeObject.T) : " m3tn 
                 " RAISES { Scheme.E }"
                 )
                )
         )
    ((env 'get 'convert-blt) 'insert! (string->symbol pname))

    (define (make-intf) (string-append proto ";"))
    
    (define (make-impl)
      (string-append
       proto " = " dnl
       "  BEGIN" dnl
       "    WITH ref = SchemeModula3Types.ToModula_"basename"(x) DO" dnl
       "      RETURN NARROW(ref, REF "basename")^" dnl
       "    END" dnl
       "  END " pname ";" dnl
       ))
    (cons (make-intf) (make-impl))))

(define *making-type* #f)
(define *making-env* #f)

(define (make-to-modula type env)
  ;; this routine ONLY gets called for extension types (WIDECHAR, LONGINT)
  ;; and compound types
  (set! *making-type* type)
  (set! *making-env* env)

  ;;(dis "(make-to-modula " (stringify type) ")" dnl)
  
  (if (is-basetype type)
      ;; special handling for extension types
      (make-to-modula-baseref (is-basetype type) env)

      (make-to-modula-nonbase type env)))

(define (make-to-scheme-baseref basename env)
  (let* ((type (extract-field basename the-basetypes))
         (m3tn                       ;; type name
          (type-formatter type env))

         (m3ti                       ;; identifier mangled from tn
          (m3type->m3identifier (type-formatter type env)))

         (pname (to-scheme-proc-name type env))

         (imports (env 'get 'imports))

         (proto (string-append
                 "PROCEDURE " pname "(READONLY x : " m3tn 
                 ") : SchemeObject.T RAISES {"
                 (if (member? (car type) '(Ref Procedure Object Opaque))
                     ""
                     " Scheme.E")
                 " }"
                 )
                )
         )
    ((env 'get 'convert-blt) 'insert! (string->symbol pname))

    (define (make-intf) (string-append proto ";"))

    (define (make-impl)
      (string-append
       proto " = " dnl
       "  BEGIN" dnl
       "    WITH ref = NEW(REF " basename ") DO" dnl
       "      ref^ := x;" dnl
       "      RETURN SchemeModula3Types.ToScheme_" basename "(ref)" dnl
       "    END" dnl
       "  END " pname ";" dnl
       ))

    (cons (make-intf) (make-impl))))


(define (make-to-scheme type env)
  ;; this routine ONLY gets called for extension types (WIDECHAR, LONGINT)
  ;; and compound types
  (if (is-basetype type)
      ;; special handling for extension types
      (make-to-scheme-baseref (is-basetype type) env)

      (make-to-scheme-nonbase type env)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-conversion-routines type env)
  ;; make only the legal conversion routines
  ;; none for base types
  ;; to-scheme only for open arrays
  ;; to-scheme and to-modula for all others
  (if (is-basetype type) 
      #f
      (cons (make-to-scheme type env)
            (if (eq? (car type) 'OpenArray) 
                '()
                (list (make-to-modula type env))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (format-exception-catcher x env)
  (let* ((qid (extract-field 'qid x))
         (xname (stringify-qid (cleanup-qid qid) "." env))
         (imports (env 'get 'imports))
         (arg (extract-field 'arg x)) 
         )

    (imports 'insert! 'SchemeApply)
    (imports 'insert! 'SchemeSymbol)

    (if (null? arg)
        (string-append 
         "      | " xname " => EVAL SchemeApply.OneArg(interp,excHandler,SchemeUtils.List2("(make-symbol 'quote env)",SchemeUtils.List1("(make-symbol xname env)")))" dnl
         )
        (let ((xarg->scm (to-scheme-proc-name arg env)))

          (string-append
           "      | " xname "(xarg) => EVAL SchemeApply.OneArg(interp,excHandler,SchemeUtils.List2("(make-symbol 'quote env)",SchemeUtils.Cons("(make-symbol xname env)", " xarg->scm "(xarg))))" dnl
           )
          )
        )
    )
  )

(define (filter-tree tree match-list converter)
  ;; very generic routine to search a tree for a "path" and
  ;; call converter on everything found down that path.
  ;; see prefix-formals for an example
  (map 
   (lambda (p) 
     (if (and (pair? p) 
              (eq? (car match-list) (car p)))  ;; any match?
         (if (null? (cdr match-list))          ;; final match?
             (cons (car p) (converter (cdr p)));; yes - convert 
             (cons (car p)                     ;; no - recurse
                   (filter-tree (cdr p) (cdr match-list) converter)))
         p ;; anything else
         ))
   tree))

(define (make-formal mode name type . default)
  `(Formal (mode . ,mode)(outOnly . #f)(name . ,name) (type . ,type) (default . , default)))

(define (prefix-formals prefix proc-type)
  ;; add a prefix to all the formals of a procedure (or method?) 
  ;; declaration
  (filter-tree proc-type 
               '(sig formals Formal name)
               (lambda(formal-name)
                 (string->symbol (string-append prefix formal-name)))))


(define (make-procedure-call-stub proc env)
  (let* ((qid (car proc))
         (m3pn (stringify-qid (cleanup-qid qid) "." env))
         (u3pn (stringify-qid (cleanup-qid qid) "_" env))
         (stub-name (string-append "CallStub_" u3pn))
         (proc-type (prefix-formals 'formal_ (cdr proc)))
         )

    (let ((stubs (env 'get 'procedure-call-stubs))
          (qualified-name (cleanup-qid qid)) 
          )
      (stubs 'delete-entry! qualified-name)
      (stubs 'add-entry! qualified-name stub-name))

    (make-named-procedure-call-stub proc-type m3pn u3pn stub-name "" env)))

(define ( make-named-procedure-call-stub 
          proc-type ;; definition
          m3pn      ;; modula-3 name for procedure to call
          u3pn      ;; name to use for making parts of stub
          stub-name ;; name for actual stub
					special-prolog ;; nil checks e.g.
          env )
  ;; idea is that this can be used with method definitions too

  (let* ((imports (env 'get 'imports))
         (sig (extract-field 'sig proc-type)))
    
    (define (formal-type-converter type)
      (case (car type)
        ((OpenArray) (formal-type-converter (make-ref-type type)))
        (else (to-modula-proc-name type env))))

    (define (make-formal-temp f)
      (string-append
       (extract-field 'name f)
       " := "
       (formal-type-converter (extract-field 'type f))
       "(Next())"
       ))

    (define (format-call) 
      (let* ((formals (extract-field 'formals sig))
             (arg-list (infixize
                        (map (lambda (f) 
                               ;; open arrays we allocate as REF <type>
                               ;; and de-ref on call
                               (if (eq? (car (extract-field 'type f))
                                        'OpenArray) 
                                   (string-append
                                    (extract-field 'name f)
                                    "^" )
                                   (extract-field 'name f))
                               )
                             (filter (lambda(f)
                                       (not (eq? 'Mode.Implied
                                                 (extract-field 'mode f))))
                                     formals))
                        ", "))
             (result (extract-field 'result sig)))

        (define (format-nil-checks)
          (apply string-append
                 (map (lambda(f)
                        (string-append
                         "        EVAL SchemeUtils.CheckNonNil("
                         (extract-field 'name f)
                         ");" dnl))
                      (filter 
                       (lambda (f) 
                         (eq? (car (extract-field 'type f)) 'OpenArray))
                       formals)
                      )))

        (define (unpack-var f)
          (let* ((arg-type (extract-field 'type f))
                 (arg-name (extract-field 'name f))
                 (deref-caret (if (eq? (car arg-type) 'OpenArray) "^" "")))
            (string-append
             (if (eq? (extract-field 'mode f) 'Mode.Var)
                 (string-append
                  "        EVAL SchemeUtils.SetFirst(p__," (to-scheme-proc-name arg-type env)"(" arg-name deref-caret"));" dnl
                  )
                 ""
                 )
             "        EVAL Next();" dnl 
             )
            ))

        (define (unpack-var-params) 
          ;; fill this in
          (string-append
           "        p__ := SchemePair.Pair(args);" dnl
           (apply string-append (map unpack-var formals))
           )
          )

        (string-append 
         "      (* unpack formals *)" dnl
         "      VAR "
         (infixize  (cons "<*NOWARN*>junk__ := 0" (map make-formal-temp formals))
                    (string-append ";" dnl "           ")) "; BEGIN" dnl

                    "        (* carry out NIL checks for open arrays *)" dnl
                    (format-nil-checks) dnl

                    "        (* carry out passed-in checks *)" dnl
										special-prolog
										

                    "        (* make procedure call *)" dnl
                    (if (null? result)
                        (string-append
                         "        " m3pn"("arg-list");" dnl
                         "        (* unpack VAR params *)" dnl
                         (unpack-var-params) dnl
                         "        (* proper procedure : return TRUE *)" dnl
                         "        RETURN SchemeBoolean.True()"
                         )
                        (string-append
                         "        WITH res = " (to-scheme-proc-name result env) "("m3pn"("arg-list")) DO" dnl
                         "        (* unpack VAR params *)" dnl
                         (unpack-var-params) dnl
                         "        (* return procedure result *)" dnl
                         "        RETURN res" dnl
                         "        END" 
                         )
                        ) dnl
                          "      END(*WITH*)" dnl
                          )))   
    
    (define (format-exception-handling) 
      (let ((exceptions (extract-field 'raises sig)))
        ;; exceptions null? RAISES ANY
        ;; exceptions '(()) RAISES {}
        ;; exceptions '((X)) RAISES { X }

        (if (null? exceptions)
            (begin
              (imports 'insert! 'SchemeApply)
              (imports 'insert! 'SchemeSymbol)
              (string-append
               "      ELSE" dnl
               "        EVAL SchemeApply.OneArg(interp,excHandler,SchemeUtils.List2("(make-symbol 'quote env)",SchemeUtils.List1("(make-symbol 'ANY env)")))" dnl
               )
              )
            (apply string-append
                   (map (lambda(x)(format-exception-catcher x env))
                        (car exceptions))))))

    (imports 'insert! 'Scheme)
    (imports 'insert! 'SchemeObject)
    (imports 'insert! 'SchemeUtils)
    (imports 'insert! 'SchemePair)
    (imports 'insert! 'SchemeBoolean)

    (string-append
     "PROCEDURE "stub-name"(interp : Scheme.T;" dnl
     "                      args : SchemeObject.T;" dnl
     "                      excHandler : SchemeObject.T) : SchemeObject.T" dnl
     "  RAISES { Scheme.E } = " dnl
     " " dnl
     "  PROCEDURE Next() : SchemeObject.T RAISES { Scheme.E } = " dnl
     "    BEGIN" dnl
     "      TRY RETURN SchemeUtils.First(p__) FINALLY p__ := SchemePair.Pair(SchemeUtils.Rest(p__)) END" dnl
     "    END Next;" dnl  
     " " dnl
     "  VAR p__ := SchemePair.Pair(args);" dnl
     "  BEGIN" dnl
     "    TRY" dnl
     (format-call)
     "    EXCEPT" dnl
     (format-exception-handling)
     "    END;" dnl
     "    <*NOWARN*>RETURN SchemeBoolean.False()" dnl
     "  END " stub-name ";"  dnl
     )))


;; (make-procedure-call-stub (car the-procs) global-env)
;; (map (lambda(p)(make-procedure-call-stub p global-env)) the-procs)

(define dnldnl (string-append dnl dnl))

(define (close-conversions env)
  (let* ((built-sofar (env 'get 'convert-blt))
         (missing->m3  (env 'get 'convert->m3-req))
         (missing->scm (env 'get 'convert->scm-req)))

    (map (lambda(k)
           (missing->m3 'delete-entry! k)
           (missing->scm 'delete-entry! k))
         (built-sofar 'keys))

    (if (and (= 0 (missing->m3 'size)) (= 0 (missing->scm 'size)))
        '() ;; base case
        (let ((this
               (append
                (map (lambda (k)
                       (make-to-scheme (missing->scm 'retrieve k) env))
                     (missing->scm 'keys))
                (map (lambda (k)
;;                       (dis "making " k dnl)
                       (make-to-modula (missing->m3 'retrieve k) env))
                     (missing->m3 'keys)))))
          (append this (close-conversions env))))))

(define (spit-out intf-name proc-stubs converters types env)
  (cons
   (spit-out-intf intf-name proc-stubs (map car converters) env)
   (spit-out-impl intf-name proc-stubs (map cdr converters) types env)
   )
  )

(define (spit-out-intf intf-name proc-stubs converter-intfs env)
  (string-append
   (if is-unsafe "UNSAFE " "") "INTERFACE " intf-name ";" dnl
   "(* AUTOMATICALLY GENERATED DO NOT EDIT *)" dnl
   (format-imports env)
   dnl
   "PROCEDURE RegisterStubs();" dnl
   dnl
   (infixize converter-intfs dnldnl)
   dnl
   "CONST Brand = \"" intf-name "\";" dnl
   dnl
   "END " intf-name "." dnl
   )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (string-flatten-list lst)
  (define (helper x)
    (if (list? x) 
        (string-flatten-list x)
        x))
  (apply string-append (map helper lst)) )

;;(define (string-flatten . lst)
;;  (string-flatten-list lst))

(define (get-elements x)
  (cond ((null? x) '())
        ((pair? x) (append (get-elements (car x)) (get-elements (cdr x))))
        (else (list x))))

(define (string-flatten . lst)
  ;; this one is much faster because it uses array indexing in string-append
  ;; and then only a single Wx
  (apply string-append (get-elements lst)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-register-stubs input-registrations env)
  (string-flatten
   "PROCEDURE RegisterStubs() = " dnl
   "  BEGIN" dnl
   input-registrations
   (let* ((stubs (env 'get 'procedure-call-stubs))
          (qids (stubs 'keys)))
     
     (define (formatter k)
       (string-append
        "    SchemeProcedureStubs.Register(NEW(SchemeProcedureStubs.Qid, intf := Atom.FromText(\"" (car k) "\"), item := Atom.FromText(\"" (cdr k) "\")), "(stubs 'retrieve k)");" 
        )
       )
     
     (infixize (map formatter qids) dnl)
     ) dnl
       "  END RegisterStubs;" dnl
       ))

(define (is-object-type? type)
  (and 
   (pair? type)
   (or 
    (eq? (car type) 'Object)
    (and (eq? (car type) 'Opaque)
         (is-object-type? (extract-field 'revealedSuperType type))))))

(define (is-ref-record-type? type)
  (and 
   (pair? type)
   (eq? (car type) 'Ref)
   (eq? (car (extract-field 'target type)) 'Record)))

(define (is-ref-array-type? type)
  (and 
   (pair? type)
   (eq? (car type) 'Ref)
   (or
    (eq? (car (extract-field 'target type)) 'Array)
    (eq? (car (extract-field 'target type)) 'OpenArray))))

(define (is-ref-type? type)
  (and 
   (pair? type)
   (eq? (car type) 'Ref)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (format-pickle-vector vec)
  (define res '())
  (infixize
   (let loop ((i (- (vector-length vec) 1))
              (res '()))
     (if (= -1 i) 
         res
         (loop (- i 1) 
               (cons 
                (string-append "VAL(" (vector-ref vec i) ",CHAR)")
                res))))
   ", "))

(define (register-pickle types env)

  (define (format-typecodes)
    (infixize 
     (map (lambda (t) (format-typecode t env)) types)
     ", "
     ))

  (define (format-typenames)
    (infixize 
     (map (lambda (t) 
            (string-append "\"" (type-formatter t env) "\""))
          types)
     ", "
     ))

  ((env 'get 'imports) 'insert! 'SchemeProcedureStubs)
  ((env 'get 'imports) 'insert! 'RT0)

  (let ((type-pickle (encode-pickle-vector types)))
    (string-flatten
     "    VAR" dnl
     "      Arg_TC := ARRAY [0.." (- (length types) 1) "] OF [-1..LAST(RT0.Typecode)] { " (format-typecodes) "};" dnl
     "    CONST" dnl
     "      Arg_Names = ARRAY OF TEXT { " (format-typenames) "};" dnl
     "      Arg_Pickle = ARRAY OF CHAR { " (format-pickle-vector type-pickle) " };" dnl
     "    BEGIN" dnl
     "      SchemeProcedureStubs.RegisterTypePickle(Arg_TC, Arg_Names, Arg_Pickle)" dnl
     "    END;" dnl
     )
    ))


(define (format-typecode type env)
  (if (and 
       (is-reference-type? type)
       (not (eq? (car type) 'Procedure)))
      (string-append "TYPECODE(" (type-formatter type env) ")")
      "-1"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (spit-out-impl intf-name proc-stubs converter-impls types env)
  (define (env-map func types)
    (map (lambda(t)(func t env)) types))

  ;; we have one little limitation so far...  we dont discover that
  ;; something is an array type or ref array type while processing the
  ;; current interface unless its already been given its own distinct
  ;; typename.  This mainly hits procedure return values---if we want
  ;; to unpack them, the user needs to specify the types separately
  ;; somehow.

  (let* ((imports (env 'get 'imports))

         ;;;;;;;;;;;; REF types ;;;;;;;;;;;;
         (ref-types (filter is-ref-type? types))

         (ref-ops 
          (env-map make-ref-ops ref-types))

         (ref-registrations
          (env-map make-ref-registrations ref-types))

         ;;;;;;;;;;;; REF ARRAY types ;;;;;;;;;;;;
         (ref-array-types (filter is-ref-array-type? types))
         
         (ref-array-ops
          (env-map make-ref-array-ops ref-array-types))

         (ref-array-registrations
          (env-map make-ref-array-registrations ref-array-types))


         ;;;;;;;;;;;; REF RECORD types ;;;;;;;;;;;;
         (ref-record-types (filter is-ref-record-type? types))

         (ref-record-registrations 
          (env-map make-ref-record-registrations ref-record-types))

         (ref-record-ops 
          (env-map make-ref-record-ops ref-record-types))

         (ref-record-field-stubs
          (env-map make-field-stubs ref-record-types))


         ;;;;;;;;;;;; types <: OBJECT END ;;;;;;;;;;;;
         (object-types (filter is-object-type? types))

         (object-stubs 
          (env-map make-object-surrogate object-types))

         (object-field-stubs 
          (env-map make-field-stubs object-types))

         (object-method-stubs
          (env-map make-method-stubs object-types))

         (object-registrations 
          (env-map make-object-registrations object-types))
         
         ;;;;;;;;;;;; the global pickle ;;;;;;;;;;;;
         (the-pickle        (register-pickle types env))
         (register-stubs
          (make-register-stubs 
           (append
            ref-record-registrations
            object-registrations 
            ref-registrations
            ref-array-registrations
            the-pickle
            )
           env))

         (converters (infixize (map cdr (close-conversions env)) dnldnl))
         

         )
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (imports 'insert! 'SchemeProcedureStubs)
    (imports 'insert! 'Atom)
    (imports 'insert! 'SchemePair)
    
    (string-flatten
     (if is-unsafe "UNSAFE " "") "MODULE " intf-name ";" dnl
     "(* AUTOMATICALLY GENERATED DO NOT EDIT *)" dnl
     (format-imports env)
     dnl
     (infixize proc-stubs dnl) dnl
     dnl
     
     (string-flatten
      register-stubs
      dnl
      object-stubs
      dnl
      object-field-stubs
      dnl
      object-method-stubs
      dnl
      ref-record-field-stubs
      dnl
      ref-record-ops
      dnl
      ref-array-ops
      dnl
      ref-ops
      )

     dnl

     (infixize converter-impls dnldnl)
     dnl

     ;; more converters... hrmph shouldnt really be here
     converters
     dnl

     (format-load-time-symbols env)
     dnl

     "BEGIN END " intf-name "." dnl
     )
    )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (check-non-nil-type varname typename env)
  ((env 'get 'imports) 'insert! 'Scheme)
  ((env 'get 'imports) 'insert! 'SchemeUtils)

  (string-append
   "    IF NOT ISTYPE("varname","typename") OR "varname"=NIL THEN" dnl
   "      RAISE Scheme.E(\"Not of type "typename" : \" & SchemeUtils.Stringify("varname"))" dnl
   "    END;" dnl
   )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-method-stubs type env)
   (let ((m3tn (type-formatter type env))
        (m3ti (m3type->m3identifier (type-formatter type env)))
        (imports (env 'get 'imports))
        (methods (visible-methods type))
        )

     (define (make-method-lister mname)
      (string-append "    res := SchemeUtils.Cons("(make-symbol mname env)", res);" dnl)
      )

    (imports 'insert! 'SchemeUtils)
    (imports 'insert! 'Scheme)
    (imports 'insert! 'SchemeObject)


    (string-flatten
     "PROCEDURE MethodList_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  VAR" dnl
     "    res : SchemePair.T := NIL;" dnl
     "    narrow : " m3tn ";" dnl
     "  BEGIN" dnl
     (map make-method-lister (methods 'keys))
     "    RETURN res" dnl
     "  END MethodList_" m3ti ";" dnl
     dnl
)))

(define (make-field-stubs type env)
  (let ((m3tn (type-formatter type env))
        (m3ti (m3type->m3identifier (type-formatter type env)))
        (imports (env 'get 'imports))
        (fields (visible-fields type))
        )

    (define (make-field-lister fname)
      (string-append "    res := SchemeUtils.Cons("(make-symbol fname env)", res);" dnl)
    )

    (define (make-field-getter fname)
      (let* ((field (fields 'retrieve fname))
             (ftype (extract-field 'type field)))
        (string-append
         "    ELSIF field = "(make-symbol fname env) " THEN " dnl
         "      RETURN "(to-scheme-proc-name ftype env)"(narrow." fname")" dnl
         )))

    (define (make-field-setter fname)
      (let* ((field (fields 'retrieve fname))
             (ftype (extract-field 'type field)))
        (string-append
         "    ELSIF field = "(make-symbol fname env)" THEN " dnl
         "      res := "(to-scheme-proc-name ftype env)"(narrow." fname");" dnl
         "      narrow." fname" := "(to-modula-proc-name ftype env)"(value)" dnl
         )))

    (imports 'insert! 'SchemeUtils)
    (imports 'insert! 'Scheme)
    (imports 'insert! 'SchemeObject)

    (string-flatten
     "PROCEDURE FieldList_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  VAR" dnl
     "    res : SchemePair.T := NIL;" dnl
     "    narrow : " m3tn ";" dnl
     "  BEGIN" dnl
     (map make-field-lister (fields 'keys))
     "    RETURN res" dnl
     "  END FieldList_" m3ti ";" dnl
     dnl

     "PROCEDURE FieldGet_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  VAR" dnl
     "    field   := SchemeUtils.First(args);" dnl
     "    narrow : " m3tn ";" dnl
     "  BEGIN" dnl
     (check-non-nil-type "obj" m3tn env)
     "    narrow := NARROW(obj,"m3tn");" dnl
     "    IF FALSE THEN <*ASSERT FALSE*>" dnl
     (map make-field-getter (fields 'keys))
     "    ELSE RAISE Scheme.E(\"Unknown field \" & SchemeUtils.Stringify(field))" dnl
     "    END" dnl
     "  END FieldGet_" m3ti ";" dnl
     dnl

     "PROCEDURE FieldSet_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  VAR" dnl
     "    field   := SchemeUtils.First(args);" dnl
     "    value   := SchemeUtils.First(SchemeUtils.Rest(args));" dnl
     "    narrow : " m3tn ";" dnl
     "    res : SchemeObject.T;" dnl
     "  BEGIN" dnl
     (check-non-nil-type "obj" m3tn env)
     "    narrow := NARROW(obj,"m3tn");" dnl
     "    IF FALSE THEN <*ASSERT FALSE*>" dnl
     (map make-field-setter (fields 'keys))
     "    ELSE RAISE Scheme.E(\"Unknown field \" & SchemeUtils.Stringify(field))" dnl
     "    END;" dnl
     "    RETURN res" dnl
     "  END FieldSet_" m3ti ";" dnl
     dnl

     )
    )
  )

(define (make-object-surrogate type env)
  (let ((m3tn (type-formatter type env))
        (m3ti (m3type->m3identifier (type-formatter type env)))
        (imports (env 'get 'imports))
        (surrogate-type-name
         (string-append
          (m3type->m3identifier (type-formatter type env))
          "_Surrogate"))

        (methods ((visible-methods type) 'values)))

    (define (scheme-slot-name method)
      (string-append (extract-field 'name method) "_slot"))

    (define (override-name method)
      (string-append m3ti "_" (extract-field 'name method) "_default"))

    (define (format-scheme-slots)
      (imports 'insert! 'SchemeObject)
      (apply 
       string-append
       (map (lambda(m)
              (string-append 
               "    " (scheme-slot-name m) " : SchemeObject.T := NIL; " dnl)
              )
            methods)
       ))

    (define (format-default-overrides)
      (apply 
       string-append
       (map (lambda (m)
              (string-append
               "    " (extract-field 'name m) " := " (override-name m) ";" dnl)
              )
            methods)))

    (define (make-object-surrogate-decl)
      (imports 'insert! 'Scheme)

      (string-append
       "TYPE " surrogate-type-name " = " m3tn " OBJECT " dnl
       "    interp : Scheme.T;" dnl
       (format-scheme-slots)
       "  OVERRIDES" dnl
       (format-default-overrides)
       "  END;" dnl
       dnl
       )
      )

    (define (make-default-method m)
      (let* ((sig (extract-field 'sig (prefix-formals 'formal_ m)))
             (have-return 
              (if (null? (extract-field 'result sig)) 
                  #f
                  (extract-field 'result sig)))
             (name (extract-field 'name m)))

        (define (format-punt-call) 
          (let ((vars (map 
                       (lambda(f)(extract-field 'name f)) 
                       (extract-field 'formals sig))))
            (string-append
             "      (* punt to Modula-3 object type defn *)" dnl
             "      " (if have-return "RETURN " "") m3tn"."name"("
             (infixize (cons 'object__ vars) ", ") ")" dnl
             
             )
            )
          )

        (define (format-arg-to-scheme f)
          (imports 'insert! 'SchemeUtils)

          (string-append
           "        args__ := SchemeUtils.Cons("
           (to-scheme-proc-name (extract-field 'type f) env)
           "(" (extract-field 'name f) ")"
           ",args__);" dnl
           )
          )

        (define (format-override-call) 
          (map 
           (lambda(i)(imports 'insert! i))
           '(SchemePair SchemeProcedureStubs SchemeUtils))

          (string-append
           "      (* method overriden by Scheme code *)" dnl
           "      VAR" dnl
           "        args__ : SchemePair.T := NEW(SchemePair.T, first := object__, rest := NIL);" dnl
           "      BEGIN" dnl
           (apply string-append
                  (map format-arg-to-scheme (extract-field 'formals sig)))
           "        args__ := SchemeUtils.Reverse(args__);" dnl

           "        " (if have-return 
                          (string-append "RETURN " (to-modula-proc-name have-return env ) "(")
                          "EVAL (")
           "SchemeProcedureStubs.CallScheme(object__.interp, "
           "object__."(scheme-slot-name m)", "
           "args__))" dnl
           "        (* and this is where we need to unpack VAR params *)" dnl
           "      END" dnl
           )
          )

        (string-append
         "PROCEDURE " (override-name m) 
         (format-parenthesized-signature sig 
                                         env 
                                         (string-append
                                          "object__ : " surrogate-type-name)) 
         " = " dnl
         "  BEGIN" dnl
         "    IF object__." (scheme-slot-name m) " = NIL THEN" dnl
         (format-punt-call)
         "    ELSE" dnl
         (format-override-call)
         "    END" dnl
         "  END " (override-name m) ";" dnl dnl
         
         )
        ))

    (define (make-object-ops)

      (define (format-field-initializer f)
        (let ((type (extract-field 'type f))
              (name (extract-field 'name f)))
          (imports 'insert! 'SchemeSymbol)
          (string-append
           "            IF r.first = "(make-symbol name env)" THEN" dnl
           "              res." name " := "(to-modula-proc-name type env)"(r.rest); gobbled := TRUE" dnl
           "            END;" dnl
           )))

      (define (format-field-initializers) 
        (apply string-append
               (map format-field-initializer  
                    ((visible-fields type) 'values))))
      
      
      
      (define (format-method-override m)
        (imports 'insert! 'SchemeSymbol)
        (let ((name (extract-field 'name m)))
          (string-append
           "            IF r.first = "(make-symbol name env)" THEN" dnl
           "               res." (scheme-slot-name m) " := r.rest; gobbled := TRUE" dnl
           "            END;" dnl
           )))

      (define (format-method-overrides) 
        (apply string-append
               (map format-method-override methods)
               )
        )


      (map 
       (lambda(i)(imports 'insert! i))
       '(SchemePair Scheme SchemeObject))
      
      (string-flatten
       "PROCEDURE New_" m3ti "(interp : Scheme.T; inits : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
       "  VAR" dnl
       "    p := SchemePair.Pair(inits);" dnl
       "    gobbled : BOOLEAN;" dnl
       "  BEGIN" dnl
       "    WITH res = NEW("surrogate-type-name", interp := interp) DO" dnl
       "      WHILE p # NIL DO" dnl
       "        WITH r = SchemePair.Pair(p.first) DO" dnl
       "          gobbled := FALSE;" dnl
       "          IF r # NIL THEN" dnl
       (format-field-initializers)
       (format-method-overrides)
       "          END;" dnl
       "          IF NOT gobbled THEN" dnl
       "            RAISE Scheme.E(\""m3ti": Unknown field/method \" & SchemeUtils.Stringify(r.first) & \" in \" & SchemeUtils.Stringify(inits))" dnl
       "          END" dnl
       "        END;" dnl
       "        p := SchemePair.Pair(p.rest)" dnl
       "      END;" dnl
       "      RETURN res" dnl
       "    END" dnl
       "  END New_" m3ti ";" dnl
       dnl

       "PROCEDURE GenNew_" m3ti "(interp : Scheme.T; <*UNUSED*>obj : SchemeObject.T; inits : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
       "  BEGIN RETURN New_" m3ti "(interp,inits) END GenNew_" m3ti ";" dnl
       dnl

       ))

    (define (make-method-dispatcher)
      (imports 'insert! 'SchemeSymbol)
      (imports 'insert! 'SchemeUtils)

      (define (make-dispatch-method meth-name)
        (string-append
         "    ELSIF methName = "(make-symbol meth-name env)" THEN"dnl
         "      RETURN MethodStub_" m3ti "_" meth-name "(interp,methArgs,methExcHandler)" dnl
         ))

      (string-flatten
       "PROCEDURE MethodDispatcher_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
       "  VAR" dnl
       "    methName := Scheme.SymbolCheck(SchemeUtils.First(args));" dnl
       "    methArgs := SchemeUtils.Cons(obj,SchemeUtils.Second(args));" dnl
       "    methExcHandler := SchemeUtils.Third(args);" dnl
       "  BEGIN" dnl
       "    IF FALSE THEN <*ASSERT FALSE*>" dnl
       (map make-dispatch-method ((visible-methods type) 'keys))
       "    ELSE" dnl
       "      RAISE Scheme.E(\"unknown method \"&SchemeSymbol.ToText(methName)&\" for type "m3tn"\");" dnl
       "    END" dnl
       "  END MethodDispatcher_" m3ti ";" dnl
       dnl
       ))

    (define (make-method-dispatch method)
      ;; make dispatch for a single method 
      (let* ((name              (extract-field 'name method))
             (meth-sig          (make-method-call-sig method type))
             (method-call-name  (string-append 'this "." name))
             )
        (make-named-procedure-call-stub meth-sig 
                                        method-call-name
                                        (m3type->m3identifier
                                         method-call-name)
                                        (string-append
                                         "MethodStub_" m3ti "_" name)
																				(string-append
																				 "        IF this = NIL THEN" dnl
                                         "          RAISE Scheme.E(\"null object\")" dnl
																				 "        END;" dnl
                                        )
                                        env)
        ))
    
    (cons
     (make-object-ops)
     (append
      (list
       (make-object-surrogate-decl)
       (make-method-dispatcher)
       )
      (map make-default-method methods)
      (map make-method-dispatch methods)
      )
     )
    )
  )

(define (make-method-call-sig method type)
  (let* ((proc-type (prefix-formals 'formal_ method)))

    (filter-tree proc-type
                 '(sig formals)
                 (lambda(formals)
                   (cons (make-formal 'Mode.Implied 'this type) formals))

                 )
    ))

(define (make-an-op-registration type name proc-name env)
  ((env 'get 'imports) 'insert! 'SchemeProcedureStubs)
  (string-append
   "    SchemeProcedureStubs.RegisterOp(TYPECODE("
   (type-formatter type env)
   "),\"" name  "\"," proc-name");" dnl
   ))

(define (make-a-tc-registration type name env)
  ((env 'get 'imports) 'insert! 'SchemeProcedureStubs)
  (string-append
   "    SchemeProcedureStubs.RegisterTC(TYPECODE("(type-formatter type env)
   "),\"" name "\");" dnl
   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-ref-record-ops type env)
  (let ((m3tn (type-formatter type env))
        (m3ti (m3type->m3identifier (type-formatter type env)))
        (imports (env 'get 'imports)))
    
    (define (format-field-initializer f)
      (let ((type (extract-field 'type f))
            (name (extract-field 'name f)))
        (imports 'insert! 'SchemeSymbol)
        (string-append
         "            IF r.first = " (make-symbol name env)" THEN" dnl
         "              res." name " := "(to-modula-proc-name type env)"(r.rest); gobbled := TRUE" dnl
         "            END;" dnl
         )))
    
    
    (define (format-field-initializers) 
      (apply string-append
             (map format-field-initializer  
                  ((visible-fields type) 'values))))
    
    (map 
     (lambda(i)(imports 'insert! i))
     '(SchemePair Scheme SchemeObject))
    
    (string-flatten
     "PROCEDURE New_" m3ti "(<*UNUSED*>interp : Scheme.T; inits : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  VAR" dnl
     "    p := SchemePair.Pair(inits);" dnl
     "    gobbled : BOOLEAN;" dnl
     "  BEGIN" dnl
     "    WITH res = NEW("m3tn") DO" dnl
     "      WHILE p # NIL DO" dnl
     "        WITH r = SchemePair.Pair(p.first) DO" dnl
     "          gobbled := FALSE;" dnl
     "          IF r # NIL THEN" dnl
     (format-field-initializers)
     "          END;" dnl
     "          IF NOT gobbled THEN" dnl
     "            RAISE Scheme.E(\"Unknown field in \" & SchemeUtils.Stringify(inits))" dnl
     "          END" dnl
     "        END;" dnl
     "        p := SchemePair.Pair(p.rest)" dnl
     "      END;" dnl
     "      RETURN res" dnl
     "    END" dnl
     "  END New_" m3ti ";" dnl
     dnl
     
     "PROCEDURE GenNew_" m3ti "(interp : Scheme.T; <*UNUSED*>obj : SchemeObject.T; inits : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  BEGIN RETURN New_" m3ti "(interp,inits) END GenNew_" m3ti ";" dnl
     dnl
     
     ))
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-ref-type target)
  (list 'Ref 
        (cons 'traced #t)
        (cons 'target target)
        ))

(define (convert-value-to-modula type value env)
  (case (car type)
    ((OpenArray)
     (string-append
      (to-modula-proc-name (make-ref-type type)
                           env)
      "(" value ")^")
     )

    (else
     (string-append 
      (to-modula-proc-name type env) "(" value ")"))
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (array-dimensions type)
  (case (car type)
    ((OpenArray)
     (cons (extract-field 'CARDINAL the-basetypes)
           (array-dimensions (extract-field 'element type))))
    ((Array)
     (cons (extract-field 'index type)
           (array-dimensions (extract-field 'element type))))
    (else '())))

(define (skip n lst)
  (if (= n 0) 
      lst
      (skip (- n 1) (cdr lst))))

(define (make-assigner specified-indices array-type env)

  (define (first-elem d arr)
    (if (= d 0) 
        arr
        (let ((next (first-elem (- d 1) arr)))
          (string-append 
           next "[FIRST(" next ")]"
           ))))

  (define (check-dims n)
    ;; checks one more than n.  n is the dims to "traverse" before checking
    (if (< n 0) 
        ""
        (string-flatten
         (check-dims (- n 1))
         "      IF NUMBER("(first-elem n "tgt")") # NUMBER("(first-elem n "src")") THEN" dnl
         "        RAISE Scheme.E(\"array shape mismatch\")" dnl
         "      END;" dnl
         ))
    )

  (define (reduce-dimension atype n)
    (if (= n 0) 
        atype 
        (reduce-dimension (extract-field 'element atype) (- n 1))))

  (let* ((dims (array-dimensions array-type))
         (assigner-type (reduce-dimension array-type specified-indices))
         (tn (type-formatter assigner-type env))
         (dims-to-traverse (- (length dims) specified-indices 1))
         )
    (string-flatten
     "  PROCEDURE Assign"specified-indices"(VAR tgt : " tn "; READONLY src : " tn ") " 

     (if (= -1 dims-to-traverse) 
         "" 
         "RAISES { Scheme.E } ") 

     "= " dnl
     "    BEGIN" dnl
     "      (* max. dims-to-traverse = " dims-to-traverse " *)" dnl
     (check-dims dims-to-traverse)
     "      tgt := src" dnl
     "    END Assign"specified-indices";" dnl
     dnl
     )
    )
  )


(define (make-assigners array-type env)
  (let loop ((d (length (array-dimensions array-type))))
    (if (< d 0) 
        ""
        (string-flatten (make-assigner d array-type env)
                        (loop (- d 1))))
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-ref-array-ops type env)
  (let* ((m3tn (type-formatter type env))
         (m3ti (m3type->m3identifier (type-formatter type env)))
         (atype (extract-field 'target type))
         (dims (array-dimensions atype))
         
         (imports (env 'get 'imports)))

    (define (index-decls)
      (let loop ((i 0)
                 (d dims))
        (if (null? d) 
            '()
            (cons
             (string-append 
              "    i"i" : "(type-formatter (car d) env)";" dnl
              )
             (loop (+ i 1) (cdr d))))))
    
    (define (format-dims n)
      (if (= 1 n) "i0" (string-append (format-dims (- n 1))  ", i"(- n 1))))

    (define (format-pre i)
      (if (= 0 i) 
          "a^"
          (string-append "a["(format-dims i)"]")
          ))

    (define (check-indices)
      (let loop ((i 0)
                 (d dims))
        (if (null? d) '()
            (cons
             (string-append
              "    IF indices > "i" THEN " dnl
              "      i"i" := "(to-modula-proc-name (car d) env)"(SchemeUtils.Nth(args,"i"));" dnl
              "      WITH pre = "(format-pre i)"," dnl
              "           lst = i"i" DO" dnl
              "        IF lst < FIRST(pre) OR lst > LAST(pre) THEN" dnl
              "          RAISE Scheme.E(\"array index out of range : \" & SchemeUtils.Stringify(args))" dnl
              "        END" dnl
              "      END" dnl
              "    END;" dnl
              )
             (loop (+ i 1) (cdr d))))))

    (define (make-output)
      (string-flatten
       "    CASE indices OF" dnl
       (let loop ((i 1)
                  (d dims)
                  (t atype))
         (if (null? d) '()
             (cons
              (string-append
               "    | " i " => RETURN "(to-scheme-proc-name (extract-field 'element t) env)"("(format-pre i)")" dnl
               )
              (loop (+ i 1) (cdr d) (extract-field 'element t)))
             )
         
         )
       "    ELSE" dnl
       "      RAISE Scheme.E(\"too many array indices : \" & SchemeUtils.Stringify(args))" dnl
       "    END" dnl
       ))

    (define (make-input)
      (string-flatten
       "    CASE indices OF" dnl
       (let loop ((i 1)
                  (d dims)
                  (t atype))
         (if (null? d) '()
             (cons
              (string-append
               "    | " i " => Assign"i"("(format-pre i)", "(convert-value-to-modula 
                                                             (extract-field 'element t) 
                                                             "val"
                                                             env) ")" dnl
                                                             )
              (loop (+ i 1) (cdr d) (extract-field 'element t)))
             )
         
         )
       "    ELSE" dnl
       "      RAISE Scheme.E(\"too many array indices : \" & SchemeUtils.Stringify(args))" dnl
       "    END" dnl
       ))

    (define (make-limit op)
      (string-flatten
       "    CASE indices OF" dnl
       (let loop ((i 0))
         (if (= (length dims) i)
             (string-append
              "    ELSE" dnl
              "      RAISE Scheme.E(\"too many array indices : \" & SchemeUtils.Stringify(args))" dnl
              "    END" dnl
              )
             (cons
              (string-append
               "    | " i " => RETURN SchemeLongReal.FromI("op"("(format-pre i)"))" dnl
               )
              (loop (+ i 1))
              )
             )
         )))

    (define (make-limit-op proc-prefix op)
      (string-flatten
       "PROCEDURE "proc-prefix"_"m3ti"(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
       "  VAR" dnl
       "    indices := SchemeUtils.Length(args);" dnl 
       "    a : " m3tn ";" dnl
       (index-decls)
       "  BEGIN"dnl
       (check-non-nil-type "obj" m3tn env)
       "    a := obj;" dnl
       (make-limit op)
       "  END "proc-prefix"_"m3ti";" dnl
       dnl
       ))

    (imports 'insert! 'Scheme)
    (imports 'insert! 'SchemeObject)
    (imports 'insert! 'SchemeUtils)

    (string-flatten
     "PROCEDURE GetElement_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  VAR" dnl
     "    indices := SchemeUtils.Length(args);" dnl
     (index-decls)
     "    a : " m3tn ";" dnl
     "  BEGIN" dnl
     (check-non-nil-type "obj" m3tn env)
     "    a := obj;" dnl
     "    IF indices = 0 THEN" dnl
     "      RAISE Scheme.E(\"must specify at least one array index\")" dnl
     "    END;" dnl
     (check-indices)
     (make-output)
     "  END GetElement_" m3ti ";" dnl
     dnl

     (make-limit-op "Last" "LAST")
     (make-limit-op "First" "FIRST")
     (make-limit-op "Number" "NUMBER")

     "PROCEDURE SetElement_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  PROCEDURE CheckCard(c : INTEGER) : CARDINAL RAISES { Scheme.E } = "dnl
     "    BEGIN" dnl
     "      IF c < FIRST(CARDINAL) THEN RAISE Scheme.E(\"not a cardinal\") END;" dnl
     "      RETURN c" dnl
     "    END CheckCard;" dnl
     dnl
     (make-assigners atype env)
     "  VAR" dnl
     "    n       := SchemeUtils.Length(args);" dnl
     "    indices := CheckCard(n - 1);" dnl
     (index-decls)
     "    val     := SchemeUtils.Nth(args,indices);" dnl
     "    a : " m3tn ";" dnl
     "  BEGIN" dnl
     (check-non-nil-type "obj" m3tn env)
     "    a := obj;" dnl
     "    IF indices = 0 THEN" dnl
     "      RAISE Scheme.E(\"must specify at least one array index\")" dnl
     "    END;" dnl
     (check-indices)
     (make-input) ";" dnl
     "    RETURN obj"
     "  END SetElement_" m3ti ";" dnl
     dnl

     )
    ))

(define (make-ref-array-registrations arr-type env)
  (let* ((m3tn  (type-formatter arr-type env))
         (m3ti  (m3type->m3identifier m3tn))
         (alias (cleanup-qid (extract-field 'alias arr-type)))
         (name  (cleanup-qid (extract-field 'alias arr-type)))

         (last-name       (string-append "Last_" m3ti))         
         (first-name       (string-append "First_" m3ti))
         (number-name       (string-append "Number_" m3ti))

         (setter-name     (string-append "SetElement_" m3ti))
         (getter-name     (string-append "GetElement_" m3ti))
         )
    ((env 'get 'imports) 'insert! 'SchemeProcedureStubs)
    ((env 'get 'imports) 'insert! 'Atom)
    (string-flatten
     (make-an-op-registration arr-type 'get-element getter-name env)
     (make-an-op-registration arr-type 'set-element! setter-name env)

     (make-an-op-registration arr-type 'last last-name env)
     (make-an-op-registration arr-type 'first first-name env)
     (make-an-op-registration arr-type 'number number-name env)

     (make-a-tc-registration arr-type m3tn env)
     ;; we can introduce type aliases here as well

     )
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-ref-ops type env)
  (let ((m3tn (type-formatter type env))
        (m3ti (m3type->m3identifier (type-formatter type env)))
        (target (extract-field 'target type))
        (imports (env 'get 'imports)))

    (define (make-open-array-dims)
      (if (eq? (car target) 'OpenArray)
          (let loop ((dims (extract-field 'openDimensions target)))
            (imports 'insert! 'SchemeLongReal)
            (if (= dims 0) 
                ""
                (string-append
                 (loop (- dims 1))
                 ", SchemeLongReal.Card(SchemeUtils.Nth(allArgs, "(- dims 1)"))"
                 )
                ))
          "")
      )

    (imports 'insert! 'SchemeUtils)
    (imports 'insert! 'SchemeObject)
    (imports 'insert! 'Scheme)

    (string-flatten
     "PROCEDURE DeRef_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  BEGIN" dnl
     (check-non-nil-type "obj" m3tn env)
     "    WITH x = NARROW(obj, "m3tn") DO" dnl
     "      RETURN " (to-scheme-proc-name target env) "(x^)" dnl
     "    END" dnl
     "  END DeRef_" m3ti ";" dnl
     dnl

     "PROCEDURE MakeRef_" m3ti "(interp : Scheme.T; obj : SchemeObject.T; args : SchemeObject.T) : SchemeObject.T RAISES { Scheme.E } =" dnl
     "  VAR allArgs := SchemeUtils.Cons(obj,args);" dnl
     "      res := NEW(" m3tn (make-open-array-dims) ");" dnl
     "  BEGIN" dnl
     "    RETURN res" dnl
     "  END MakeRef_" m3ti ";" dnl
     dnl

     )))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-object-registrations obj-type env)
  (let* ((m3tn  (type-formatter obj-type env))
         (m3ti  (m3type->m3identifier m3tn))

         (lister-name     (string-append "MethodList_" m3ti))
         (dispatcher-name (string-append "MethodDispatcher_" m3ti))
         )

    (string-flatten
     (make-an-op-registration obj-type 'call-method dispatcher-name env)
     (make-an-op-registration obj-type 'list-methods lister-name env)

     ;; reuse everything from REF RECORD:
     (make-ref-record-registrations obj-type env)))) 

(define (make-ref-record-registrations obj-type env)
  (let* ((m3tn  (type-formatter obj-type env))
         (m3ti  (m3type->m3identifier m3tn))
         (alias (cleanup-qid (extract-field 'alias obj-type)))
         (name  (cleanup-qid (extract-field 'alias obj-type)))
         
         (new-name        (string-append "New_" m3ti))
         (gen-new-name    (string-append "GenNew_" m3ti))
         (setter-name     (string-append "FieldSet_" m3ti))
         (getter-name     (string-append "FieldGet_" m3ti))
         (lister-name     (string-append "FieldList_" m3ti))
         )
    ((env 'get 'imports) 'insert! 'SchemeProcedureStubs)
    ((env 'get 'imports) 'insert! 'Atom)
    (string-flatten
     "    SchemeProcedureStubs.RegisterNew(NEW(SchemeProcedureStubs.Qid, intf := Atom.FromText(\""(car alias)"\"), item := Atom.FromText(\""(cdr alias)"\")), "new-name");" dnl
     (make-an-op-registration obj-type 'new gen-new-name env)
     (make-an-op-registration obj-type 'list-fields lister-name env)
     (make-an-op-registration obj-type 'get-field getter-name env)
     (make-an-op-registration obj-type 'set-field! setter-name env)

     (make-a-tc-registration obj-type m3tn env)
     ;; we can introduce type aliases here as well

     )
    )
  )

(define (make-ref-registrations ref-type env)
  (let* ((m3tn  (type-formatter ref-type env))
         (m3ti  (m3type->m3identifier m3tn))
         (alias (cleanup-qid (extract-field 'alias ref-type)))
         (name  (cleanup-qid (extract-field 'alias ref-type)))
         
         (deref-name        (string-append "DeRef_" m3ti))
         (makeref-name        (string-append "MakeRef_" m3ti)))
    (string-flatten
     (make-an-op-registration ref-type 'deref deref-name env)
     (make-an-op-registration ref-type 'makeref makeref-name env)
     (make-a-tc-registration ref-type m3tn env)
     )
    )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (visible-what what)
  (let ((res '()))
    (set! res
          (lambda(obj-type)
            ;; a type can only have methods if its opaque or object
            (if (null? obj-type) 
                (make-symbol-hash-table 100)

                (case (car obj-type)
                  ((Ref)
                   (let ((target (extract-field 'target obj-type))
                         (res (make-symbol-hash-table 100)))
                     (if (not (eq? (car target) 'Record))
                         (error "Cant get " what " from " obj-type))
                     (map (lambda(m)
                            (res 'update-entry!
                                 (extract-field 'name m)
                                 m))
                          (extract-field what target))
                     res))

                  ((Object)
                   (let ((super-visible 
                          (res (extract-field 'super obj-type))))
                     (map 
                      (lambda(m)
                        (super-visible 'update-entry!
                                       (extract-field 'name m)
                                       m))
                      
                      (extract-field what obj-type))
                     super-visible))

                  ((Opaque)
                   (res (extract-field 'revealedSuperType obj-type)))

                  (else (error "Cant get " what " from " obj-type))))))
    res))

(define visible-methods (visible-what 'methods))

(define visible-fields (visible-what 'fields))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; (make-procedure-call-stub (car the-procs) global-env)

(define (write-files intf-name procs types env)
  (let* ((proc-stubs (map (lambda(p)(make-procedure-call-stub p env)) procs))
         (converters (close-conversions env))
         (im (spit-out intf-name proc-stubs converters types env))
         (iwr (open-output-file (string-append intf-name ".i3")))
         (mwr (open-output-file (string-append intf-name ".m3"))))

    (display (car im) iwr)
    (display (cdr im) mwr)
    
    (close-output-port iwr) (close-output-port mwr)

    proc-stubs
    ))

(define (stale-output? intf-name)
  (if config-check-staleness
      (let ((stale #f)
            (srcs the-sourcefiles)
            (tgts (map (lambda(sfx)(string-append intf-name sfx)) '(".i3" ".m3"))))

        ;;        (dis "srcs: " srcs dnl)
        ;;        (dis "src-time: " (apply max (map fs-status-modificationtime srcs)) dnl)
        ;;       (dis "tgts: " tgts dnl)
        ;;       (dis "tgt-time: " (apply min (map fs-status-modificationtime tgts)) dnl)
        
        (unwind-protect
         (set! stale (< (apply min (map fs-status-modificationtime tgts))
                        (apply max (map fs-status-modificationtime srcs))))
         ()
         (set! stale #t))
        stale)
      #t))

(define (rename-if-different root1 root2)
  (define (cmp-files-safely fn1 fn2)
    (let ((res #f))
      (unwind-protect
       (begin (set! res (cmp-files fn1 fn2)) res)
       ()
       #f)
      res))

  (define (rename-file-if-different fn1 fn2)
    (if (not (cmp-files-safely fn1 fn2)) (fs-rename fn1 fn2)))
  
  (rename-file-if-different (string-append root1 ".i3") (string-append root2 ".i3"))
  (rename-file-if-different (string-append root1 ".m3") (string-append root2 ".m3"))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;                           ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;   m3build/cm3  helpers    ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;       (extra stuff)       ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;                           ;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (strip-extension sym)
  (string->symbol
   (car (pregexp-split "\\." 
                       (symbol->string sym)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; pure testing code...
(define (make-list n . x) 

  (define (kar x)
    (if (null? x) '() (car x))) 

  (if (= 0 n) 
      (cons 0 (kar x)) 
      (make-list (- n 1) (cons n (kar x)))))
